THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:54.834843 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 208 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122749
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 208 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 208 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	3


VOMongoRepositoryResolver>>execute:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aBlockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: li...etc...
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepository>>selectMany:where:
	Receiver: a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		selected: 	nil
	Receiver's instance variables: 
		port: 	27017
		databaseName: 	'CoRAWeb'
		host: 	'127.0.0.1'
		username: 	'admin'
		password: 	'admin123'
		cache: 	Cache(0 objects)
		descriptionBuilder: 	nil
		resolver: 	a VOMongoRepositoryResolver
		forceEager: 	false
		versionGenerator: 	a VOSeedVersionGenerator


VOMongoRepository>>selectAll:
	Receiver: a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
	Arguments and temporary variables: 
		aClass: 	Item
	Receiver's instance variables: 
		port: 	27017
		databaseName: 	'CoRAWeb'
		host: 	'127.0.0.1'
		username: 	'admin'
		password: 	'admin123'
		cache: 	Cache(0 objects)
		descriptionBuilder: 	nil
		resolver: 	a VOMongoRepositoryResolver
		forceEager: 	false
		versionGenerator: 	a VOSeedVersionGenerator


Item class(Class)>>selectAll
	Receiver: Item
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	CAModel
		methodDict: 	a MethodDictionary(#=->Item>>#= #asPropertyDictionary->Item>>#asPro...etc...
		format: 	65541
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Item
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CoRAWeb-model'
		traitComposition: 	{}
		localSelectors: 	nil


CWItemsListComponent>>items
	Receiver: a CWItemsListComponent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		urlToPost: 	nil


[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
	Receiver: a CWItemsListComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		urlToPost: 	nil


BlockClosure>>renderOn:
	Receiver: [ self items do: [ :it | self renderItem: it on: html ] ]
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	table...etc...
		startpc: 	128
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
	Receiver: a WAGenericTag
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a TBSTableTag
		closed: 	false
		attributes: 	nil
		tag: 	'tbody'


BlockClosure>>renderOn:
	Receiver: [ self before.
canvas render: anObject.
self after ]
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	WAGenericTag(WATagBrush)>>with:
		startpc: 	54
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>nest:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAGenericTag(WABrush)>>with:
	Receiver: a WAGenericTag
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a TBSTableTag
		closed: 	false
		attributes: 	nil
		tag: 	'tbody'


WAGenericTag(WATagBrush)>>with:
	Receiver: a WAGenericTag
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a TBSTableTag
		closed: 	false
		attributes: 	nil
		tag: 	'tbody'


WAHtmlCanvas>>tableBody:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
	Receiver: a CWItemsListComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		urlToPost: 	nil


BlockClosure>>renderOn:
	Receiver: [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ ...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: h...etc...
		startpc: 	110
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
	Receiver: a TBSTableTag
	Arguments and temporary variables: 
		anObject: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody...etc...
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a WAGenericTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'table')



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:54.950134 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 206 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122879
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 206 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 206 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 208 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122749
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 208 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 208 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:55.010724 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122943
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 206 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122879
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 206 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 206 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:55.061432 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 208 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122993
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 208 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 208 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122943
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in WeakIdentityKeyDictionary(Dictionary)>>at:ifAbsent:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in WeakIdentityKeyDictionary(Dictionary)>>at:ifAbsent:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in WeakIdentityKeyDictionary(Dictionary)>>at:ifAbsent:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

11 May 2017 1:45:55.109685 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 208 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122993
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 208 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 208 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122943
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in WeakIdentityKeyDictionary(Dictionary)>>at:ifAbsent:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'



--- The full stack ---
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:56.985978 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 160 62 198 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	124913
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 160 62 198 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 160 62 198 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	3


VOMongoRepositoryResolver>>execute:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aBlockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: li...etc...
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepository>>selectMany:where:
	Receiver: a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		selected: 	nil
	Receiver's instance variables: 
		port: 	27017
		databaseName: 	'CoRAWeb'
		host: 	'127.0.0.1'
		username: 	'admin'
		password: 	'admin123'
		cache: 	Cache(0 objects)
		descriptionBuilder: 	nil
		resolver: 	a VOMongoRepositoryResolver
		forceEager: 	false
		versionGenerator: 	a VOSeedVersionGenerator


VOMongoRepository>>selectAll:
	Receiver: a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
	Arguments and temporary variables: 
		aClass: 	Item
	Receiver's instance variables: 
		port: 	27017
		databaseName: 	'CoRAWeb'
		host: 	'127.0.0.1'
		username: 	'admin'
		password: 	'admin123'
		cache: 	Cache(0 objects)
		descriptionBuilder: 	nil
		resolver: 	a VOMongoRepositoryResolver
		forceEager: 	false
		versionGenerator: 	a VOSeedVersionGenerator


Item class(Class)>>selectAll
	Receiver: Item
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	CAModel
		methodDict: 	a MethodDictionary(#=->Item>>#= #asPropertyDictionary->Item>>#asPro...etc...
		format: 	65541
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Item
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CoRAWeb-model'
		traitComposition: 	{}
		localSelectors: 	nil


CWItemsListComponent>>items
	Receiver: a CWItemsListComponent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		urlToPost: 	nil


[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
	Receiver: a CWItemsListComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		urlToPost: 	nil


BlockClosure>>renderOn:
	Receiver: [ self items do: [ :it | self renderItem: it on: html ] ]
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	table...etc...
		startpc: 	128
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
	Receiver: a WAGenericTag
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a TBSTableTag
		closed: 	false
		attributes: 	nil
		tag: 	'tbody'


BlockClosure>>renderOn:
	Receiver: [ self before.
canvas render: anObject.
self after ]
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	WAGenericTag(WATagBrush)>>with:
		startpc: 	54
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>nest:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAGenericTag(WABrush)>>with:
	Receiver: a WAGenericTag
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a TBSTableTag
		closed: 	false
		attributes: 	nil
		tag: 	'tbody'


WAGenericTag(WATagBrush)>>with:
	Receiver: a WAGenericTag
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a TBSTableTag
		closed: 	false
		attributes: 	nil
		tag: 	'tbody'


WAHtmlCanvas>>tableBody:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
	Receiver: a CWItemsListComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		urlToPost: 	nil


BlockClosure>>renderOn:
	Receiver: [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ ...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: h...etc...
		startpc: 	110
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
	Receiver: a TBSTableTag
	Arguments and temporary variables: 
		anObject: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody...etc...
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a WAGenericTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'table')



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:57.047278 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	124971
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 160 62 198 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	124913
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 160 62 198 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 160 62 198 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in Socket>>waitForConnectionFor:ifTimedOut:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in Socket>>waitForConnectionFor:ifTimedOut:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in Socket>>waitForConnectionFor:ifTimedOut:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:57.100782 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	125029
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	124971
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:57.151883 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	125085
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	125029
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

11 May 2017 1:45:57.202009 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	125085
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	125029
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'



--- The full stack ---
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
VOMongoConnectionError
11 May 2017 1:45:57.252218 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

VOMongoExecuteStrategy>>visitError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	VOMongoConnectionError
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoConnectionError(Error)>>acceptVOMongoExecuteError:
	Receiver: VOMongoConnectionError
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		signalContext: 	VOMongoConnectionError(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	VOMongoConnectionError
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	VOMongoConnectionError
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	VOMongoConnectionError
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	VOMongoConnectionError
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


VOMongoConnectionError(Exception)>>signalIn:
	Receiver: VOMongoConnectionError
	Arguments and temporary variables: 
		context: 	ConnectionTimedOut(Exception)>>signal
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		signalContext: 	VOMongoConnectionError(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>resignalAs:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		replacementException: 	VOMongoConnectionError
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


VOMongoExecuteStrategy>>resignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	125085
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0



--- The full stack ---
VOMongoExecuteStrategy>>visitError:
VOMongoConnectionError(Error)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
VOMongoConnectionError(Exception)>>signalIn:
ConnectionTimedOut(Exception)>>resignalAs:
VOMongoExecuteStrategy>>resignal:
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "not" is nil
11 May 2017 2:49:47.273063 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

UndefinedObject(Object)>>doesNotUnderstand: #not
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	not
		exception: 	MessageNotUnderstood: receiver of "not" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

CWAdminComponent>>renderContentOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
		group: 	a WARadioGroup
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WAToolDecoration(WADecoration)>>renderNextOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderChildOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderContentOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>acceptDecorated:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAPainter)>>renderWithContext:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderPhaseContinuation>>processRendering:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aResponse: 	a WABufferedResponse status: 200 message: 'OK'
		document: 	a WAHtmlDocument
		actionContinuation: 	a WACallbackProcessingActionContinuation
		renderContext: 	a WARenderContext
		actionUrl: 	/admin?_s=_ANYVEhGrOnv61LB&_k=SkVvRhejlo6Kdg7f
		actionBaseUrl: 	/admin?_s=_ANYVEhGrOnv61LB&_k=SkVvRhejlo6Kdg7f
		htmlRoot: 	a WAHtmlRoot
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_debugAction=_debug'
		response: 	a WABufferedResponse status: 200 message: 'OK'
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


WARequestContext>>respond:
	Receiver: a WARequestContext url: '/admin?_debugAction=_debug'
	Arguments and temporary variables: 
		aBlock: 	[ :response | self processRendering: response ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WARenderPhaseContinuation a WAInitialRenderLoo...etc...
		request: 	a WARequest method: GET uri: /admin?_debugAction=_debug version: HTTP/...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	a GRSmallDictionary()


WARenderPhaseContinuation(WASessionContinuation)>>respond:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[ :response | self processRendering: response ]
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


WARenderPhaseContinuation>>handleFiltered:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_debugAction=_debug'
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_debugAction=_debug'
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


BlockClosure>>on:do:
	Receiver: [ self filter handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
		handlerAction: 	[ :notification | notification resume: anObject ]
	Receiver's instance variables: 
		outerContext: 	WARenderPhaseContinuation(WARequestHandler)>>handle:
		startpc: 	32
		numArgs: 	0


WACurrentRequestContext class(WADynamicVariable class)>>use:during:
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 
		anObject: 	a WARequestContext url: '/admin?_debugAction=_debug'
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_debugAction=_debug'
	Arguments and temporary variables: 
		aRequestHandler: 	a WARenderPhaseContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WARenderPhaseContinuation a WAInitialRenderLoo...etc...
		request: 	a WARequest method: GET uri: /admin?_debugAction=_debug version: HTTP/...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	a GRSmallDictionary()


BlockClosure>>ensure:
	Receiver: [ WACurrentRequestContext use: self during: aBlock ]
	Arguments and temporary variables: 
		aBlock: 	[ handlers removeFirst ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WARequestContext>>push:during:
		startpc: 	42
		numArgs: 	0


WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_debugAction=_debug'
	Arguments and temporary variables: 
		aRequestHandler: 	a WARenderPhaseContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WARenderPhaseContinuation a WAInitialRenderLoo...etc...
		request: 	a WARequest method: GET uri: /admin?_debugAction=_debug version: HTTP/...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	a GRSmallDictionary()



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #not
CWAdminComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWAdminComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWAdminComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: WAHtmlCanvas>>group
11 May 2017 2:59:39.751071 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

WAHtmlCanvas(Object)>>doesNotUnderstand: #group
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aMessage: 	group
		exception: 	MessageNotUnderstood: WAHtmlCanvas>>group
		resumeValue: 	nil
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


[ html group radioButton
	selected: PersistenceManager isLocal;
	callback: [ PersistenceManager beLocalWithEmptyRepository ].
html text: 'Local (starts with an empty repository)' ] in CWAdminComponent>>renderContentOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
		group: 	a WARadioGroup
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


BlockClosure>>renderOn:
	Receiver: [ html group radioButton
	selected: PersistenceManager isLocal;
	callback: [ PersistenceMa...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	CWAdminComponent>>renderContentOn:
		startpc: 	82
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


[ self before.
canvas render: anObject.
self after ] in TBSInputGroupTag(WATagBrush)>>with:
	Receiver: a TBSInputGroupTag
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'input-group')


BlockClosure>>renderOn:
	Receiver: [ self before.
canvas render: anObject.
self after ]
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	TBSInputGroupTag(WATagBrush)>>with:
		startpc: 	54
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


WAHtmlCanvas(WACanvas)>>nest:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


TBSInputGroupTag(WABrush)>>with:
	Receiver: a TBSInputGroupTag
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'input-group')


TBSInputGroupTag(WATagBrush)>>with:
	Receiver: a TBSInputGroupTag
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'input-group')


WAHtmlCanvas>>tbsInputGroup:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	callba...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


CWAdminComponent>>renderContentOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
		group: 	a WARadioGroup
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WAToolDecoration(WADecoration)>>renderNextOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderChildOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderContentOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>acceptDecorated:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor



--- The full stack ---
WAHtmlCanvas(Object)>>doesNotUnderstand: #group
[ html group radioButton
	selected: PersistenceManager isLocal;
	callback: [ PersistenceManager beLocalWithEmptyRepository ].
html text: 'Local (starts with an empty repository)' ] in CWAdminComponent>>renderContentOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSInputGroupTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSInputGroupTag(WABrush)>>with:
TBSInputGroupTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsInputGroup:
CWAdminComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWAdminComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CWAdminComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: WAHtmlCanvas>>group
11 May 2017 2:59:58.837396 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

WAHtmlCanvas(Object)>>doesNotUnderstand: #group
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aMessage: 	group
		exception: 	MessageNotUnderstood: WAHtmlCanvas>>group
		resumeValue: 	nil
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


[ html group radioButton
	selected: PersistenceManager isLocal;
	callback: [ PersistenceManager beLocalWithEmptyRepository ].
html text: 'Local (starts with an empty repository)' ] in CWAdminComponent>>renderContentOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
		group: 	a WARadioGroup
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


BlockClosure>>renderOn:
	Receiver: [ html group radioButton
	selected: PersistenceManager isLocal;
	callback: [ PersistenceMa...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	CWAdminComponent>>renderContentOn:
		startpc: 	82
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


[ self before.
canvas render: anObject.
self after ] in TBSInputGroupTag(WATagBrush)>>with:
	Receiver: a TBSInputGroupTag
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'input-group')


BlockClosure>>renderOn:
	Receiver: [ self before.
canvas render: anObject.
self after ]
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	TBSInputGroupTag(WATagBrush)>>with:
		startpc: 	54
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


WAHtmlCanvas(WACanvas)>>nest:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


TBSInputGroupTag(WABrush)>>with:
	Receiver: a TBSInputGroupTag
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'input-group')


TBSInputGroupTag(WATagBrush)>>with:
	Receiver: a TBSInputGroupTag
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'input-group')


WAHtmlCanvas>>tbsInputGroup:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	callba...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


CWAdminComponent>>renderContentOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
		group: 	a WARadioGroup
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WAToolDecoration(WADecoration)>>renderNextOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderChildOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderContentOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>acceptDecorated:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor



--- The full stack ---
WAHtmlCanvas(Object)>>doesNotUnderstand: #group
[ html group radioButton
	selected: PersistenceManager isLocal;
	callback: [ PersistenceManager beLocalWithEmptyRepository ].
html text: 'Local (starts with an empty repository)' ] in CWAdminComponent>>renderContentOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSInputGroupTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSInputGroupTag(WABrush)>>with:
TBSInputGroupTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsInputGroup:
CWAdminComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWAdminComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CWAdminComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ZnHttpUnsuccessful: 400 Bad Request
11 May 2017 3:44:00.796767 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

ZnClient>>handleResponse
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>executeWithRedirectsRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		redirectCount: 	3
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ self executeWithRedirectsRemaining: self maxNumberOfRedirects ] in ZnClient>>executeWithRetriesRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		retryCount: 	0
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


BlockClosure>>on:do:
	Receiver: [ self executeWithRedirectsRemaining: self maxNumberOfRedirects ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :exception | 
retryCount > 0
	ifTrue: [ self
			handleRetry: e...etc...
	Receiver's instance variables: 
		outerContext: 	ZnClient>>executeWithRetriesRemaining:
		startpc: 	49
		numArgs: 	0


ZnClient>>executeWithRetriesRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		retryCount: 	0
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ self executeWithRetriesRemaining: self numberOfRetries ] in [ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


BlockClosure>>on:do:
	Receiver: [ self executeWithRetriesRemaining: self numberOfRetries ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :exception | 
((exception isKindOf: ZnHttpUnsuccessful)
	and: ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on:...etc...
		startpc: 	46
		numArgs: 	0


[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ ^ block value ] in ZnClient>>withTimeoutDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
...etc...
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ p psValueAt: index put: anObject.
aBlock value ] in ZnConnectionTimeout(DynamicVariable)>>value:during:
	Receiver: a ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	1


BlockClosure>>ensure:
	Receiver: [ p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ZnConnectionTimeout(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


ZnConnectionTimeout(DynamicVariable)>>value:during:
	Receiver: a ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	1


ZnConnectionTimeout class(DynamicVariable class)>>value:during:
	Receiver: ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZnConnectionTimeout
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Variables'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a ZnConnectionTimeout


ZnClient>>withTimeoutDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
...etc...
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ result := self executeWithTimeout ] in ZnClient>>execute
	Receiver: a ZnClient
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ ^ block value ] in ZnClient>>withProgressDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ result := self executeWithTimeout ]
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ p psValueAt: index put: anObject.
aBlock value ] in ZnSignalProgress(DynamicVariable)>>value:during:
	Receiver: a ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	true
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


BlockClosure>>ensure:
	Receiver: [ p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ZnSignalProgress(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


ZnSignalProgress(DynamicVariable)>>value:during:
	Receiver: a ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	true
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


ZnSignalProgress class(DynamicVariable class)>>value:during:
	Receiver: ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	true
		aBlock: 	[ ^ block value ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZnSignalProgress
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Variables'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a ZnSignalProgress


ZnClient>>withProgressDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ result := self executeWithTimeout ]
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>execute
	Receiver: a ZnClient
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>head
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>head:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		url: 	'http://smalltalkhub.com/mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz'
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


MCSmalltalkhubRepository>>includesFileNamed:
	Receiver: a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWeb/main/)
	Arguments and temporary variables: 
		aString: 	'CoRAWeb-Casco.17.mcz'
	Receiver's instance variables: 
		creationTemplate: 	'MCSmalltalkhubRepository
	owner: ''casco''
	project: ''CoRAW...etc...
		cache: 	a Dictionary('CoRAWeb-Casco.10.mcz'->a MCVersion(CoRAWeb-Casco.10) 'CoRA...etc...
		allFileNames: 	nil
		cacheFileNames: 	false
		location: 	nil
		user: 	'casco'
		password: 	'rodrigo'
		readerCache: 	a Dictionary('CoRAWeb-Casco.10.mcz'->a MCMczReader )
		owner: 	'casco'
		project: 	'CoRAWeb'


MCSmalltalkhubRepository>>includesVersionNamed:
	Receiver: a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWeb/main/)
	Arguments and temporary variables: 
		aString: 	'CoRAWeb-Casco.17'
	Receiver's instance variables: 
		creationTemplate: 	'MCSmalltalkhubRepository
	owner: ''casco''
	project: ''CoRAW...etc...
		cache: 	a Dictionary('CoRAWeb-Casco.10.mcz'->a MCVersion(CoRAWeb-Casco.10) 'CoRA...etc...
		allFileNames: 	nil
		cacheFileNames: 	false
		location: 	nil
		user: 	'casco'
		password: 	'rodrigo'
		readerCache: 	a Dictionary('CoRAWeb-Casco.10.mcz'->a MCMczReader )
		owner: 	'casco'
		project: 	'CoRAWeb'


[ :arg | 
[ versionName := self nextVersionName.
aRepository includesVersionNamed: versionName ] whileTrue ] in MCWorkingCopy>>uniqueVersionNameIn:
	Receiver: a MCWorkingCopy(CoRAWeb)
	Arguments and temporary variables: 
		aRepository: 	a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWe...etc...
		versionName: 	'CoRAWeb-Casco.17'
		arg: 	a Job
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		package: 	a MCPackage(CoRAWeb)
		modified: 	true
		ancestry: 	a MCWorkingAncestry
		counter: 	17
		repositoryGroup: 	a MCRepositoryGroup
		requiredPackages: 	an OrderedCollection()


BlockClosure>>cull:
	Receiver: [ :arg | 
[ versionName := self nextVersionName.
aRepository includesVersionNamed: version...etc...
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	MCWorkingCopy>>uniqueVersionNameIn:
		startpc: 	47
		numArgs: 	1


[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :arg | 
[ versionName := self nextVersionName.
aRepository includesVer...etc...
		currentValue: 	0
		min: 	0
		max: 	1
		title: 	'Creating unique version number'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


[ p psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	8


BlockClosure>>ensure:
	Receiver: [ p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	8


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :arg | 
[ versionName := self nextVersionName.
aRepository includesVer...etc...
		currentValue: 	0
		min: 	0
		max: 	1
		title: 	'Creating unique version number'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


BlockClosure>>ensure:
	Receiver: [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	41
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :arg | 
[ versionName := self nextVersionName.
aRepository includesVer...etc...
		currentValue: 	0
		min: 	0
		max: 	1
		title: 	'Creating unique version number'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	'Creating unique version number'
		minVal: 	0
		maxVal: 	1
		workBlock: 	[ :arg | 
[ versionName := self nextVersionName.
aRepository include...etc...
	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


ByteString(String)>>displayProgressFrom:to:during:
	Receiver: 'Creating unique version number'
	Arguments and temporary variables: 
		minVal: 	0
		maxVal: 	1
		workBlock: 	[ :arg | 
[ versionName := self nextVersionName.
aRepository include...etc...
	Receiver's instance variables: 
'Creating unique version number'


--- The full stack ---
ZnClient>>handleResponse
ZnClient>>executeWithRedirectsRemaining:
[ self executeWithRedirectsRemaining: self maxNumberOfRedirects ] in ZnClient>>executeWithRetriesRemaining:
BlockClosure>>on:do:
ZnClient>>executeWithRetriesRemaining:
[ self executeWithRetriesRemaining: self numberOfRetries ] in [ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
BlockClosure>>on:do:
[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
[ ^ block value ] in ZnClient>>withTimeoutDo:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnConnectionTimeout(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnConnectionTimeout(DynamicVariable)>>value:during:
ZnConnectionTimeout class(DynamicVariable class)>>value:during:
ZnClient>>withTimeoutDo:
ZnClient>>executeWithTimeout
[ result := self executeWithTimeout ] in ZnClient>>execute
[ ^ block value ] in ZnClient>>withProgressDo:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnSignalProgress(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnSignalProgress(DynamicVariable)>>value:during:
ZnSignalProgress class(DynamicVariable class)>>value:during:
ZnClient>>withProgressDo:
ZnClient>>execute
ZnClient>>head
ZnClient>>head:
MCSmalltalkhubRepository>>includesFileNamed:
MCSmalltalkhubRepository>>includesVersionNamed:
[ :arg | 
[ versionName := self nextVersionName.
aRepository includesVersionNamed: versionName ] whileTrue ] in MCWorkingCopy>>uniqueVersionNameIn:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ p psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MCWorkingCopy>>uniqueVersionNameIn:
MCWorkingCopy>>newVersionIn:
NautilusMonticello>>commit:in:
[ self default commit: mcpackage workingCopy in: repo ] in [ :repo :index | 
last := (aBuilder item: 'Repo' , index printString)
	label: repo description;
	parent: #('Commit in ' #, #package #name);
	order: index;
	action: [ self default commit: mcpackage workingCopy in: repo ] ] in NautilusMonticello class>>packagesCommitsMenu:
BlockClosure>>cull:
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ].
		self showShortcut ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ [ World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Could not save version.
11 May 2017 3:46:38.133749 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

MCSmalltalkhubRepository(MCHttpRepository)>>handleUnsuccessfulResponse:
	Receiver: a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWebMonitorUI/main/)
	Arguments and temporary variables: 
		aZnResponse: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
	Receiver's instance variables: 
		creationTemplate: 	'MCHttpRepository
	location: ''http://smalltalkhub.com/mc/cas...etc...
		cache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCVersion(CoRAWebMonit...etc...
		allFileNames: 	nil
		cacheFileNames: 	false
		location: 	nil
		user: 	'casco'
		password: 	'rodrigo'
		readerCache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCMczReader )
		owner: 	'casco'
		project: 	'CoRAWebMonitorUI'


[ :exception | 
(exception isKindOf: ZnHttpUnsuccessful)
	ifTrue: [ ^ self handleUnsuccessfulResponse: exception response ].
self error: 'Could not save ' , aString , ': ' , exception printString ] in [ self httpClient
	entity: entity;
	ifFail: [ :exception | 
		(exception isKindOf: ZnHttpUnsuccessful)
			ifTrue: [ ^ self handleUnsuccessfulResponse: exception response ].
		self
			error: 'Could not save ' , aString , ': ' , exception printString ];
	url: (self urlForFileNamed: aString);
	put ] in MCSmalltalkhubRepository(MCHttpRepository)>>writeStreamForFileNamed:replace:do:
	Receiver: a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWebMonitorUI/main/)
	Arguments and temporary variables: 
		aString: 	'CoRAWebMonitoringUI-Casco.8.mcz'
		ignoreBoolean: 	false
		aBlock: 	[ :s | aVersion fileOutOn: s ]
		entity: 	a ZnStreamingEntity(application/octet-stream 4577B)
		exception: 	ZnHttpUnsuccessful: 400 Bad Request
	Receiver's instance variables: 
		creationTemplate: 	'MCHttpRepository
	location: ''http://smalltalkhub.com/mc/cas...etc...
		cache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCVersion(CoRAWebMonit...etc...
		allFileNames: 	nil
		cacheFileNames: 	false
		location: 	nil
		user: 	'casco'
		password: 	'rodrigo'
		readerCache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCMczReader )
		owner: 	'casco'
		project: 	'CoRAWebMonitorUI'


BlockClosure>>cull:
	Receiver: [ :exception | 
(exception isKindOf: ZnHttpUnsuccessful)
	ifTrue: [ ^ self handleUnsuccess...etc...
	Arguments and temporary variables: 
		anArg: 	ZnHttpUnsuccessful: 400 Bad Request
	Receiver's instance variables: 
		outerContext: 	[ self httpClient
	entity: entity;
	ifFail: [ :exception | 
		(ex...etc...
		startpc: 	115
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ZnHttpUnsuccessful: 400 Bad Request
		value: 	nil
	Receiver's instance variables: 
		sender: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error...etc...
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self executeWithRetriesRemaining: self numberOfRetries ]


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ZnHttpUnsuccessful: 400 Bad Request
	Receiver's instance variables: 
		sender: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error...etc...
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self executeWithRetriesRemaining: self numberOfRetries ]


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ZnHttpUnsuccessful: 400 Bad Request
	Receiver's instance variables: 
		sender: 	ZnClient>>executeWithRetriesRemaining:
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self executeWithRedirectsRemaining: self maxNumberOfRedirects ]


ZnHttpUnsuccessful(Exception)>>signal
	Receiver: ZnHttpUnsuccessful: 400 Bad Request
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'400 Bad Request'
		tag: 	nil
		signaler: 	a ZnClient
		signalContext: 	ZnHttpUnsuccessful(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)


ZnClient>>handleResponse
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>executeWithRedirectsRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		redirectCount: 	3
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ self executeWithRedirectsRemaining: self maxNumberOfRedirects ] in ZnClient>>executeWithRetriesRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		retryCount: 	2
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


BlockClosure>>on:do:
	Receiver: [ self executeWithRedirectsRemaining: self maxNumberOfRedirects ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :exception | 
retryCount > 0
	ifTrue: [ self
			handleRetry: e...etc...
	Receiver's instance variables: 
		outerContext: 	ZnClient>>executeWithRetriesRemaining:
		startpc: 	49
		numArgs: 	0


ZnClient>>executeWithRetriesRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		retryCount: 	2
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ self executeWithRetriesRemaining: self numberOfRetries ] in [ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


BlockClosure>>on:do:
	Receiver: [ self executeWithRetriesRemaining: self numberOfRetries ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :exception | 
(exception isKindOf: ZnHttpUnsuccessful)
	ifTrue...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on:...etc...
		startpc: 	46
		numArgs: 	0


[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ ^ block value ] in ZnClient>>withTimeoutDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
...etc...
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ p psValueAt: index put: anObject.
aBlock value ] in ZnConnectionTimeout(DynamicVariable)>>value:during:
	Receiver: a ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	1


BlockClosure>>ensure:
	Receiver: [ p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ZnConnectionTimeout(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


ZnConnectionTimeout(DynamicVariable)>>value:during:
	Receiver: a ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	1


ZnConnectionTimeout class(DynamicVariable class)>>value:during:
	Receiver: ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZnConnectionTimeout
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Variables'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a ZnConnectionTimeout


ZnClient>>withTimeoutDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
...etc...
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ result := self executeWithTimeout ] in ZnClient>>execute
	Receiver: a ZnClient
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ ^ block value ] in ZnClient>>withProgressDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ result := self executeWithTimeout ]
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ p psValueAt: index put: anObject.
aBlock value ] in ZnSignalProgress(DynamicVariable)>>value:during:
	Receiver: a ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	true
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


BlockClosure>>ensure:
	Receiver: [ p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ZnSignalProgress(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


ZnSignalProgress(DynamicVariable)>>value:during:
	Receiver: a ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	true
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


ZnSignalProgress class(DynamicVariable class)>>value:during:
	Receiver: ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	true
		aBlock: 	[ ^ block value ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZnSignalProgress
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Variables'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a ZnSignalProgress


ZnClient>>withProgressDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ result := self executeWithTimeout ]
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>execute
	Receiver: a ZnClient
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>put
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ self httpClient
	entity: entity;
	ifFail: [ :exception | 
		(exception isKindOf: ZnHttpUnsuccessful)
			ifTrue: [ ^ self handleUnsuccessfulResponse: exception response ].
		self
			error: 'Could not save ' , aString , ': ' , exception printString ];
	url: (self urlForFileNamed: aString);
	put ] in MCSmalltalkhubRepository(MCHttpRepository)>>writeStreamForFileNamed:replace:do:
	Receiver: a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWebMonitorUI/main/)
	Arguments and temporary variables: 
		aString: 	'CoRAWebMonitoringUI-Casco.8.mcz'
		ignoreBoolean: 	false
		aBlock: 	[ :s | aVersion fileOutOn: s ]
		entity: 	a ZnStreamingEntity(application/octet-stream 4577B)
	Receiver's instance variables: 
		creationTemplate: 	'MCHttpRepository
	location: ''http://smalltalkhub.com/mc/cas...etc...
		cache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCVersion(CoRAWebMonit...etc...
		allFileNames: 	nil
		cacheFileNames: 	false
		location: 	nil
		user: 	'casco'
		password: 	'rodrigo'
		readerCache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCMczReader )
		owner: 	'casco'
		project: 	'CoRAWebMonitorUI'


[ workBlock value ] in [ :bar | 
[ workBlock value ]
	on: HTTPProgress
	do: [ :ex | 
		(ex total == nil or: [ ex amount == nil ])
			ifFalse: [ (nextUpdateTime < Time millisecondClockValue
					or: [ ex total = ex amount ])
					ifTrue: [ bar current: ex amount asFloat / ex total asFloat.
						nextUpdateTime := Time millisecondClockValue + 100 ] ].
		ex resume ] ] in MCSmalltalkhubRepository(MCHttpRepository)>>displayProgress:during:
	Receiver: a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWebMonitorUI/main/)
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		creationTemplate: 	'MCHttpRepository
	location: ''http://smalltalkhub.com/mc/cas...etc...
		cache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCVersion(CoRAWebMonit...etc...
		allFileNames: 	nil
		cacheFileNames: 	false
		location: 	nil
		user: 	'casco'
		password: 	'rodrigo'
		readerCache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCMczReader )
		owner: 	'casco'
		project: 	'CoRAWebMonitorUI'


BlockClosure>>on:do:
	Receiver: [ workBlock value ]
	Arguments and temporary variables: 
		exception: 	HTTPProgress
		handlerAction: 	[ :ex | 
(ex total == nil or: [ ex amount == nil ])
	ifFalse: [ ...etc...
	Receiver's instance variables: 
		outerContext: 	[ :bar | 
[ workBlock value ]
	on: HTTPProgress
	do: [ :ex | 
		(...etc...
		startpc: 	108
		numArgs: 	0


[ :bar | 
[ workBlock value ]
	on: HTTPProgress
	do: [ :ex | 
		(ex total == nil or: [ ex amount == nil ])
			ifFalse: [ (nextUpdateTime < Time millisecondClockValue
					or: [ ex total = ex amount ])
					ifTrue: [ bar current: ex amount asFloat / ex total asFloat.
						nextUpdateTime := Time millisecondClockValue + 100 ] ].
		ex resume ] ] in MCSmalltalkhubRepository(MCHttpRepository)>>displayProgress:during:
	Receiver: a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWebMonitorUI/main/)
	Arguments and temporary variables: 
		label: 	'Uploading CoRAWebMonitoringUI-Casco.8.mcz'
		workBlock: 	[ self httpClient
	entity: entity;
	ifFail: [ :exception | 
		(excep...etc...
		nextUpdateTime: 	0
		bar: 	a Job
	Receiver's instance variables: 
		creationTemplate: 	'MCHttpRepository
	location: ''http://smalltalkhub.com/mc/cas...etc...
		cache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCVersion(CoRAWebMonit...etc...
		allFileNames: 	nil
		cacheFileNames: 	false
		location: 	nil
		user: 	'casco'
		password: 	'rodrigo'
		readerCache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCMczReader )
		owner: 	'casco'
		project: 	'CoRAWebMonitorUI'


BlockClosure>>cull:
	Receiver: [ :bar | 
[ workBlock value ]
	on: HTTPProgress
	do: [ :ex | 
		(ex total == nil or: [ ex ...etc...
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	MCSmalltalkhubRepository(MCHttpRepository)>>displayProgress:durin...etc...
		startpc: 	103
		numArgs: 	1


[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | 
[ workBlock value ]
	on: HTTPProgress
	do: [ :ex | 
		(ex tota...etc...
		currentValue: 	0.0
		min: 	0.0
		max: 	1.0
		title: 	'Uploading CoRAWebMonitoringUI-Casco.8.mcz'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


[ p psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	8


BlockClosure>>ensure:
	Receiver: [ p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0



--- The full stack ---
MCSmalltalkhubRepository(MCHttpRepository)>>handleUnsuccessfulResponse:
[ :exception | 
(exception isKindOf: ZnHttpUnsuccessful)
	ifTrue: [ ^ self handleUnsuccessfulResponse: exception response ].
self error: 'Could not save ' , aString , ': ' , exception printString ] in [ self httpClient
	entity: entity;
	ifFail: [ :exception | 
		(exception isKindOf: ZnHttpUnsuccessful)
			ifTrue: [ ^ self handleUnsuccessfulResponse: exception response ].
		self
			error: 'Could not save ' , aString , ': ' , exception printString ];
	url: (self urlForFileNamed: aString);
	put ] in MCSmalltalkhubRepository(MCHttpRepository)>>writeStreamForFileNamed:replace:do:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
Context>>handleSignal:
ZnHttpUnsuccessful(Exception)>>signal
ZnClient>>handleResponse
ZnClient>>executeWithRedirectsRemaining:
[ self executeWithRedirectsRemaining: self maxNumberOfRedirects ] in ZnClient>>executeWithRetriesRemaining:
BlockClosure>>on:do:
ZnClient>>executeWithRetriesRemaining:
[ self executeWithRetriesRemaining: self numberOfRetries ] in [ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
BlockClosure>>on:do:
[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
[ ^ block value ] in ZnClient>>withTimeoutDo:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnConnectionTimeout(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnConnectionTimeout(DynamicVariable)>>value:during:
ZnConnectionTimeout class(DynamicVariable class)>>value:during:
ZnClient>>withTimeoutDo:
ZnClient>>executeWithTimeout
[ result := self executeWithTimeout ] in ZnClient>>execute
[ ^ block value ] in ZnClient>>withProgressDo:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnSignalProgress(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnSignalProgress(DynamicVariable)>>value:during:
ZnSignalProgress class(DynamicVariable class)>>value:during:
ZnClient>>withProgressDo:
ZnClient>>execute
ZnClient>>put
[ self httpClient
	entity: entity;
	ifFail: [ :exception | 
		(exception isKindOf: ZnHttpUnsuccessful)
			ifTrue: [ ^ self handleUnsuccessfulResponse: exception response ].
		self
			error: 'Could not save ' , aString , ': ' , exception printString ];
	url: (self urlForFileNamed: aString);
	put ] in MCSmalltalkhubRepository(MCHttpRepository)>>writeStreamForFileNamed:replace:do:
[ workBlock value ] in [ :bar | 
[ workBlock value ]
	on: HTTPProgress
	do: [ :ex | 
		(ex total == nil or: [ ex amount == nil ])
			ifFalse: [ (nextUpdateTime < Time millisecondClockValue
					or: [ ex total = ex amount ])
					ifTrue: [ bar current: ex amount asFloat / ex total asFloat.
						nextUpdateTime := Time millisecondClockValue + 100 ] ].
		ex resume ] ] in MCSmalltalkhubRepository(MCHttpRepository)>>displayProgress:during:
BlockClosure>>on:do:
[ :bar | 
[ workBlock value ]
	on: HTTPProgress
	do: [ :ex | 
		(ex total == nil or: [ ex amount == nil ])
			ifFalse: [ (nextUpdateTime < Time millisecondClockValue
					or: [ ex total = ex amount ])
					ifTrue: [ bar current: ex amount asFloat / ex total asFloat.
						nextUpdateTime := Time millisecondClockValue + 100 ] ].
		ex resume ] ] in MCSmalltalkhubRepository(MCHttpRepository)>>displayProgress:during:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ p psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MCSmalltalkhubRepository(MCHttpRepository)>>displayProgress:during:
MCSmalltalkhubRepository(MCHttpRepository)>>writeStreamForFileNamed:replace:do:
MCSmalltalkhubRepository(MCFileBasedRepository)>>writeStreamForFileNamed:do:
MCSmalltalkhubRepository(MCFileBasedRepository)>>basicStoreVersion:
MCSmalltalkhubRepository(MCRepository)>>storeVersion:
MCSmalltalkhubRepository(MCFileBasedRepository)>>storeVersion:
[ super storeVersion: aVersion ] in MCSmalltalkhubRepository(MCHttpRepository)>>storeVersion:
BlockClosure>>on:do:
MCSmalltalkhubRepository(MCHttpRepository)>>retryOnCredentialRequest:
MCSmalltalkhubRepository(MCHttpRepository)>>storeVersion:
[ aRepository storeVersion: newVersion.
aRepository storeDependencies: newVersion ] in [ [ aRepository storeVersion: newVersion.
aRepository storeDependencies: newVersion ]
	ensure: [ (MCVersionInspector new version: newVersion) show ] ] in NautilusMonticello>>commit:in:
BlockClosure>>ensure:
[ [ aRepository storeVersion: newVersion.
aRepository storeDependencies: newVersion ]
	ensure: [ (MCVersionInspector new version: newVersion) show ] ] in NautilusMonticello>>commit:in:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
NautilusMonticello>>commit:in:
[ self default commit: mcpackage workingCopy in: repo ] in [ :repo :index | 
last := (aBuilder item: 'Repo' , index printString)
	label: repo description;
	parent: #('Commit in ' #, #package #name);
	order: index;
	action: [ self default commit: mcpackage workingCopy in: repo ] ] in NautilusMonticello class>>packagesCommitsMenu:
BlockClosure>>cull:
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ].
		self showShortcut ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ [ World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
11 May 2017 6:41:22.61403 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

CWAdminComponent>>renderContentOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	nil
		database: 	nil
		username: 	nil
		password: 	nil
		isLocal: 	nil
		location: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	nil
		database: 	nil
		username: 	nil
		password: 	nil
		isLocal: 	nil
		location: 	nil


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	nil
		database: 	nil
		username: 	nil
		password: 	nil
		isLocal: 	nil
		location: 	nil


CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	nil
		database: 	nil
		username: 	nil
		password: 	nil
		isLocal: 	nil
		location: 	nil


WAToolDecoration(WADecoration)>>renderNextOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderChildOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderContentOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>acceptDecorated:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	nil
		database: 	nil
		username: 	nil
		password: 	nil
		isLocal: 	nil
		location: 	nil


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAPainter)>>renderWithContext:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	nil
		database: 	nil
		username: 	nil
		password: 	nil
		isLocal: 	nil
		location: 	nil


WARenderPhaseContinuation>>processRendering:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aResponse: 	a WABufferedResponse status: 200 message: 'OK'
		document: 	a WAHtmlDocument
		actionContinuation: 	a WACallbackProcessingActionContinuation
		renderContext: 	a WARenderContext
		actionUrl: 	/admin?_s=qr1zzT0hxZ1H_6fS&_k=uZ3BwkNPW0Bn1Y8a
		actionBaseUrl: 	/admin?_s=qr1zzT0hxZ1H_6fS&_k=uZ3BwkNPW0Bn1Y8a
		htmlRoot: 	a WAHtmlRoot
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin'
		response: 	a WABufferedResponse status: 200 message: 'OK'
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


WARequestContext>>respond:
	Receiver: a WARequestContext url: '/admin'
	Arguments and temporary variables: 
		aBlock: 	[ :response | self processRendering: response ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WARenderPhaseContinuation a WAInitialRenderLoo...etc...
		request: 	a WARequest method: GET uri: /admin version: HTTP/1.1
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	a GRSmallDictionary()


WARenderPhaseContinuation(WASessionContinuation)>>respond:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[ :response | self processRendering: response ]
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


WARenderPhaseContinuation>>handleFiltered:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin'
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin'
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


BlockClosure>>on:do:
	Receiver: [ self filter handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
		handlerAction: 	[ :notification | notification resume: anObject ]
	Receiver's instance variables: 
		outerContext: 	WARenderPhaseContinuation(WARequestHandler)>>handle:
		startpc: 	32
		numArgs: 	0


WACurrentRequestContext class(WADynamicVariable class)>>use:during:
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 
		anObject: 	a WARequestContext url: '/admin'
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin'
	Arguments and temporary variables: 
		aRequestHandler: 	a WARenderPhaseContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WARenderPhaseContinuation a WAInitialRenderLoo...etc...
		request: 	a WARequest method: GET uri: /admin version: HTTP/1.1
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	a GRSmallDictionary()


BlockClosure>>ensure:
	Receiver: [ WACurrentRequestContext use: self during: aBlock ]
	Arguments and temporary variables: 
		aBlock: 	[ handlers removeFirst ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WARequestContext>>push:during:
		startpc: 	42
		numArgs: 	0


WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin'
	Arguments and temporary variables: 
		aRequestHandler: 	a WARenderPhaseContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WARenderPhaseContinuation a WAInitialRenderLoo...etc...
		request: 	a WARequest method: GET uri: /admin version: HTTP/1.1
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	a GRSmallDictionary()


WARenderPhaseContinuation(WARequestHandler)>>handle:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin'
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot



--- The full stack ---
CWAdminComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWAdminComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWAdminComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
WARequestContextNotFound
11 May 2017 6:42:45.784459 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

WACurrentRequestContext class>>defaultValue
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


WACurrentRequestContext(WADynamicVariable)>>defaultAction
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a WAHtmlCanvas
		signalContext: 	WACurrentRequestContext(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
	Receiver's instance variables: 
nil

WACurrentRequestContext(Exception)>>signal
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a WAHtmlCanvas
		signalContext: 	WACurrentRequestContext(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil


WACurrentRequestContext class(Exception class)>>signal
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


WACurrentRequestContext class(WADynamicVariable class)>>value
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


WAHtmlCanvas(WAObject)>>requestContext
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 

	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	nil


WAHtmlCanvas(WAObject)>>session
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 

	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	nil


WAHtmlCanvas>>DoIt
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 

	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'self session'
		itsSelection: 	a Text for 'self session'
		itsSelectionString: 	'self session'
	Receiver's instance variables: 
		ast: 	DoIt
	^ self session
		source: 	a ReadStream
		context: 	nil
		receiver: 	a WAHtmlCanvas
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a WAHtmlCanvas
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(129036288)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(129036288)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(940568064)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(129036288)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (545@50)
		owner: 	a TransformWithLayoutMorph(830569728)
		submorphs: 	an Array(a RubPrimarySelectionMorph(126802944) a RubCursor(33544192)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (807296000) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(745740032)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(33544192)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(424603904))
		getMenuPolicy: 	a RubEditingArea(129036288)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(940568064)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(303211008))
		viewBox: 	(0@0) corner: (1680@922)
		canvas: 	a FormCanvas on: DisplayScreen(1680x922x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(907357440))(a SearchMorp...etc...
		lastStepTime: 	133332
		lastStepMessage: 	nil
		lastCycleTime: 	133354
		alarms: 	a Heap()
		lastAlarmTime: 	133332
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1680@922)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(804941056) a GLMSystemWindow(866783744) a Na...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.96 g: 0.787 b: 0.787 alpha: 1.0)
		extension: 	a MorphExtension (649908480) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(303211008))
		viewBox: 	(0@0) corner: (1680@922)
		canvas: 	a FormCanvas on: DisplayScreen(1680x922x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(907357440))(a SearchMorp...etc...
		lastStepTime: 	133332
		lastStepMessage: 	nil
		lastCycleTime: 	133354
		alarms: 	a Heap()
		lastAlarmTime: 	133332
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(303211008))
		viewBox: 	(0@0) corner: (1680@922)
		canvas: 	a FormCanvas on: DisplayScreen(1680x922x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(907357440))(a SearchMorp...etc...
		lastStepTime: 	133332
		lastStepMessage: 	nil
		lastCycleTime: 	133354
		alarms: 	a Heap()
		lastAlarmTime: 	133332
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneSubCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		currentHand: 	a HandMorph(303211008)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(303211008))
		viewBox: 	(0@0) corner: (1680@922)
		canvas: 	a FormCanvas on: DisplayScreen(1680x922x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(907357440))(a SearchMorp...etc...
		lastStepTime: 	133332
		lastStepMessage: 	nil
		lastCycleTime: 	133354
		alarms: 	a Heap()
		lastAlarmTime: 	133332
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneSubCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1680@922)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(804941056) a GLMSystemWindow(866783744) a Na...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.96 g: 0.787 b: 0.787 alpha: 1.0)
		extension: 	a MorphExtension (649908480) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


MenuMorph>>invokeModalAt:in:allowKeyboard:
	Receiver: a MenuMorph(342479872)
	Arguments and temporary variables: 
		aPoint: 	(731@535.0)
		aWorld: 	a WorldMorph(562956288) [world]
		aBoolean: 	true
		w: 	a WorldMorph(562956288) [world]
		originalFocusHolder: 	a RubEditingArea(129036288)
	Receiver's instance variables: 
		bounds: 	(729.0@527.0) corner: (944.0@765.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(579653632)'Do it and go' a ToggleMenu...etc...
		fullBounds: 	(729.0@527.0) corner: (944.0@765.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (203113472) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(877668864)'Inspect it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	nil


MenuMorph>>invokeModal:
	Receiver: a MenuMorph(342479872)
	Arguments and temporary variables: 
		allowKeyboardControl: 	true
	Receiver's instance variables: 
		bounds: 	(729.0@527.0) corner: (944.0@765.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(579653632)'Do it and go' a ToggleMenu...etc...
		fullBounds: 	(729.0@527.0) corner: (944.0@765.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (203113472) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(877668864)'Inspect it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	nil


MenuMorph>>invokeModal
	Receiver: a MenuMorph(342479872)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(729.0@527.0) corner: (944.0@765.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(579653632)'Do it and go' a ToggleMenu...etc...
		fullBounds: 	(729.0@527.0) corner: (944.0@765.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (203113472) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(877668864)'Inspect it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	nil


[ :menu | 
menu setInvokingView: self editor.
menu invokeModal.
self changed.
^ true ] in RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
	Receiver: a RubEditingArea(129036288)
	Arguments and temporary variables: 
		shiftKeyState: 	false
		menu: 	a MenuMorph(342479872)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (545@50)
		owner: 	a TransformWithLayoutMorph(830569728)
		submorphs: 	an Array(a RubPrimarySelectionMorph(126802944) a RubCursor(33544192)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (807296000) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(745740032)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(33544192)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(424603904))
		getMenuPolicy: 	a RubEditingArea(129036288)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


MenuMorph(Object)>>ifNotNilDo:
	Receiver: a MenuMorph(342479872)
	Arguments and temporary variables: 
		aBlock: 	[ :menu | 
menu setInvokingView: self editor.
menu invokeModal.
self ch...etc...
	Receiver's instance variables: 
		bounds: 	(729.0@527.0) corner: (944.0@765.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(579653632)'Do it and go' a ToggleMenu...etc...
		fullBounds: 	(729.0@527.0) corner: (944.0@765.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (203113472) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(877668864)'Inspect it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	nil


RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
	Receiver: a RubEditingArea(129036288)
	Arguments and temporary variables: 
		shiftKeyState: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (545@50)
		owner: 	a TransformWithLayoutMorph(830569728)
		submorphs: 	an Array(a RubPrimarySelectionMorph(126802944) a RubCursor(33544192)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (807296000) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(745740032)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(33544192)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(424603904))
		getMenuPolicy: 	a RubEditingArea(129036288)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>mouseDown:
	Receiver: a RubEditingArea(129036288)
	Arguments and temporary variables: 
		evt: 	[(70@41) mouseDown yellow 132132 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (545@50)
		owner: 	a TransformWithLayoutMorph(830569728)
		submorphs: 	an Array(a RubPrimarySelectionMorph(126802944) a RubCursor(33544192)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (807296000) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(745740032)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(33544192)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(424603904))
		getMenuPolicy: 	a RubEditingArea(129036288)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>handleMouseDown:
	Receiver: a RubEditingArea(129036288)
	Arguments and temporary variables: 
		anEvent: 	[(70@41) mouseDown yellow 132132 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (545@50)
		owner: 	a TransformWithLayoutMorph(830569728)
		submorphs: 	an Array(a RubPrimarySelectionMorph(126802944) a RubCursor(33544192)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (807296000) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(745740032)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(33544192)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(424603904))
		getMenuPolicy: 	a RubEditingArea(129036288)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


MouseButtonEvent>>sentTo:
	Receiver: [(70@41) mouseDown yellow 132132 nil]
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(129036288)
	Receiver's instance variables: 
		timeStamp: 	132132
		source: 	a HandMorph(303211008)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	2
		position: 	(70@41)
		handler: 	a RubEditingArea(129036288)
		wasHandled: 	true
		whichButton: 	2


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(129036288)
	Arguments and temporary variables: 
		anEvent: 	[(70@41) mouseDown yellow 132132 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (545@50)
		owner: 	a TransformWithLayoutMorph(830569728)
		submorphs: 	an Array(a RubPrimarySelectionMorph(126802944) a RubCursor(33544192)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (807296000) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(745740032)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(33544192)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(424603904))
		getMenuPolicy: 	a RubEditingArea(129036288)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(70@41) mouseDown yellow 132132 nil]
		aMorph: 	a RubEditingArea(129036288)
		globalPt: 	(70@41)
		localEvt: 	[(70@41) mouseDown yellow 132132 nil]
		index: 	3
		child: 	a RubPrimarySelectionMorph(126802944)
		morphs: 	an Array(a RubPrimarySelectionMorph(126802944) a RubCursor(33544192))
		handler: 	a RubEditingArea(129036288)
		inside: 	false
		lastHandler: 	a RubScrolledTextMorph(940568064)
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseDown:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(70@41) mouseDown yellow 132132 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(70@41) mouseDown yellow 132132 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	132132
		source: 	a HandMorph(303211008)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	2
		position: 	(70@41)
		handler: 	a RubEditingArea(129036288)
		wasHandled: 	true
		whichButton: 	2


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(70@41) mouseDown yellow 132132 nil]
		aMorph: 	a RubEditingArea(129036288)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	28
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(70@41) mouseDown yellow 132132 nil]
		aMorph: 	a RubEditingArea(129036288)
	Receiver's instance variables: 
		morph: 	nil


RubEditingArea(Morph)>>processEvent:using:
	Receiver: a RubEditingArea(129036288)
	Arguments and temporary variables: 
		anEvent: 	[(70@41) mouseDown yellow 132132 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (545@50)
		owner: 	a TransformWithLayoutMorph(830569728)
		submorphs: 	an Array(a RubPrimarySelectionMorph(126802944) a RubCursor(33544192)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (807296000) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(745740032)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(33544192)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(424603904))
		getMenuPolicy: 	a RubEditingArea(129036288)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(731@535) mouseDown yellow 132132 nil]
		aMorph: 	a TransformWithLayoutMorph(830569728)
		globalPt: 	(731@535)
		localEvt: 	[(70@41) mouseDown yellow 132132 nil]
		index: 	1
		child: 	a RubEditingArea(129036288)
		morphs: 	an Array(a RubEditingArea(129036288))
		handler: 	nil
		inside: 	nil
		lastHandler: 	a RubScrolledTextMorph(940568064)
	Receiver's instance variables: 
		morph: 	nil



--- The full stack ---
WACurrentRequestContext class>>defaultValue
WACurrentRequestContext(WADynamicVariable)>>defaultAction
UndefinedObject>>handleSignal:
WACurrentRequestContext(Exception)>>signal
WACurrentRequestContext class(Exception class)>>signal
WACurrentRequestContext class(WADynamicVariable class)>>value
WAHtmlCanvas(WAObject)>>requestContext
WAHtmlCanvas(WAObject)>>session
WAHtmlCanvas>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldState>>doOneSubCycleFor:
WorldMorph>>doOneSubCycle
MenuMorph>>invokeModalAt:in:allowKeyboard:
MenuMorph>>invokeModal:
MenuMorph>>invokeModal
[ :menu | 
menu setInvokingView: self editor.
menu invokeModal.
self changed.
^ true ] in RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
MenuMorph(Object)>>ifNotNilDo:
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubScrolledTextMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
LazyTabGroupMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
GLMMorphBrick(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
GLMScrollPaneBandBrick(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
GLMPagerScrollBrick(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
GLMPagerBrick(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
GLMFoundationBrick(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
GLMSystemWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ [ World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
WARequestContextNotFound
11 May 2017 6:42:57.560001 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

WACurrentRequestContext class>>defaultValue
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


WACurrentRequestContext(WADynamicVariable)>>defaultAction
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a WAHtmlCanvas
		signalContext: 	WACurrentRequestContext(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
	Receiver's instance variables: 
nil

WACurrentRequestContext(Exception)>>signal
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a WAHtmlCanvas
		signalContext: 	WACurrentRequestContext(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil


WACurrentRequestContext class(Exception class)>>signal
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


WACurrentRequestContext class(WADynamicVariable class)>>value
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


WAHtmlCanvas(WAObject)>>requestContext
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 

	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	nil


WAHtmlCanvas(WAObject)>>application
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 

	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	nil


WAHtmlCanvas>>DoIt
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 

	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'self application session'
		itsSelection: 	a Text for 'self application session'
		itsSelectionString: 	'self application session'
	Receiver's instance variables: 
		ast: 	DoIt
	^ self application session
		source: 	a ReadStream
		context: 	nil
		receiver: 	a WAHtmlCanvas
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a WAHtmlCanvas
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(129036288)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(129036288)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(940568064)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(129036288)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (545@50)
		owner: 	a TransformWithLayoutMorph(830569728)
		submorphs: 	an Array(a RubPrimarySelectionMorph(126802944) a RubCursor(33544192)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (807296000) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(745740032)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(33544192)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(757582592))
		getMenuPolicy: 	a RubEditingArea(129036288)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(940568064)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(303211008))
		viewBox: 	(0@0) corner: (1680@922)
		canvas: 	a FormCanvas on: DisplayScreen(1680x922x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(411866880))(a SearchMorp...etc...
		lastStepTime: 	145157
		lastStepMessage: 	nil
		lastCycleTime: 	145179
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(33544192)))
		lastAlarmTime: 	145157
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1680@922)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(804941056) a GLMSystemWindow(866783744) a Na...etc...
		fullBounds: 	(0@0) corner: (1680@922)
		color: 	(Color r: 0.96 g: 0.787 b: 0.787 alpha: 1.0)
		extension: 	a MorphExtension (649908480) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(303211008))
		viewBox: 	(0@0) corner: (1680@922)
		canvas: 	a FormCanvas on: DisplayScreen(1680x922x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(411866880))(a SearchMorp...etc...
		lastStepTime: 	145157
		lastStepMessage: 	nil
		lastCycleTime: 	145179
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(33544192)))
		lastAlarmTime: 	145157
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(303211008))
		viewBox: 	(0@0) corner: (1680@922)
		canvas: 	a FormCanvas on: DisplayScreen(1680x922x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(411866880))(a SearchMorp...etc...
		lastStepTime: 	145157
		lastStepMessage: 	nil
		lastCycleTime: 	145179
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(33544192)))
		lastAlarmTime: 	145157
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1680@922)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(804941056) a GLMSystemWindow(866783744) a Na...etc...
		fullBounds: 	(0@0) corner: (1680@922)
		color: 	(Color r: 0.96 g: 0.787 b: 0.787 alpha: 1.0)
		extension: 	a MorphExtension (649908480) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ [ World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
WACurrentRequestContext class>>defaultValue
WACurrentRequestContext(WADynamicVariable)>>defaultAction
UndefinedObject>>handleSignal:
WACurrentRequestContext(Exception)>>signal
WACurrentRequestContext class(Exception class)>>signal
WACurrentRequestContext class(WADynamicVariable class)>>value
WAHtmlCanvas(WAObject)>>requestContext
WAHtmlCanvas(WAObject)>>application
WAHtmlCanvas>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ [ World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
WARequestContextNotFound
11 May 2017 6:43:12.113177 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

WACurrentRequestContext class>>defaultValue
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


WACurrentRequestContext(WADynamicVariable)>>defaultAction
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a WAHtmlCanvas
		signalContext: 	WACurrentRequestContext(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
	Receiver's instance variables: 
nil

WACurrentRequestContext(Exception)>>signal
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a WAHtmlCanvas
		signalContext: 	WACurrentRequestContext(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil


WACurrentRequestContext class(Exception class)>>signal
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


WACurrentRequestContext class(WADynamicVariable class)>>value
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


WAHtmlCanvas(WAObject)>>requestContext
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 

	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	nil


WAHtmlCanvas(WAObject)>>application
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 

	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	nil


WAHtmlCanvas>>DoIt
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 

	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'self application'
		itsSelection: 	a Text for 'self application'
		itsSelectionString: 	'self application'
	Receiver's instance variables: 
		ast: 	DoIt
	^ self application
		source: 	a ReadStream
		context: 	nil
		receiver: 	a WAHtmlCanvas
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a WAHtmlCanvas
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(358483968)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(358483968)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(684552960)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(358483968)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (545@50)
		owner: 	a TransformWithLayoutMorph(277095680)
		submorphs: 	an Array(a RubPrimarySelectionMorph(625718528) a RubCursor(227909376...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (438216192) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(679985408)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(227909376)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(308401664))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(684552960)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(303211008))
		viewBox: 	(0@0) corner: (1680@922)
		canvas: 	a FormCanvas on: DisplayScreen(1680x922x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(907357440))(a SearchMorp...etc...
		lastStepTime: 	159709
		lastStepMessage: 	nil
		lastCycleTime: 	159729
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(227909376)))
		lastAlarmTime: 	159709
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1680@922)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(804941056) a GLMSystemWindow(866783744) a Na...etc...
		fullBounds: 	(0@0) corner: (1680@922)
		color: 	(Color r: 0.96 g: 0.787 b: 0.787 alpha: 1.0)
		extension: 	a MorphExtension (649908480) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(303211008))
		viewBox: 	(0@0) corner: (1680@922)
		canvas: 	a FormCanvas on: DisplayScreen(1680x922x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(907357440))(a SearchMorp...etc...
		lastStepTime: 	159709
		lastStepMessage: 	nil
		lastCycleTime: 	159729
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(227909376)))
		lastAlarmTime: 	159709
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(303211008))
		viewBox: 	(0@0) corner: (1680@922)
		canvas: 	a FormCanvas on: DisplayScreen(1680x922x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(907357440))(a SearchMorp...etc...
		lastStepTime: 	159709
		lastStepMessage: 	nil
		lastCycleTime: 	159729
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(227909376)))
		lastAlarmTime: 	159709
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1680@922)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(804941056) a GLMSystemWindow(866783744) a Na...etc...
		fullBounds: 	(0@0) corner: (1680@922)
		color: 	(Color r: 0.96 g: 0.787 b: 0.787 alpha: 1.0)
		extension: 	a MorphExtension (649908480) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ [ World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
WACurrentRequestContext class>>defaultValue
WACurrentRequestContext(WADynamicVariable)>>defaultAction
UndefinedObject>>handleSignal:
WACurrentRequestContext(Exception)>>signal
WACurrentRequestContext class(Exception class)>>signal
WACurrentRequestContext class(WADynamicVariable class)>>value
WAHtmlCanvas(WAObject)>>requestContext
WAHtmlCanvas(WAObject)>>application
WAHtmlCanvas>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ [ World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
11 May 2017 6:44:28.093261 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

CWAdminComponent>>renderContentOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	nil
		database: 	nil
		username: 	nil
		password: 	nil
		isLocal: 	nil
		location: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	nil
		database: 	nil
		username: 	nil
		password: 	nil
		isLocal: 	nil
		location: 	nil


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	nil
		database: 	nil
		username: 	nil
		password: 	nil
		isLocal: 	nil
		location: 	nil


CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	nil
		database: 	nil
		username: 	nil
		password: 	nil
		isLocal: 	nil
		location: 	nil


WAToolDecoration(WADecoration)>>renderNextOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderChildOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderContentOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>acceptDecorated:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	nil
		database: 	nil
		username: 	nil
		password: 	nil
		isLocal: 	nil
		location: 	nil


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAPainter)>>renderWithContext:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	nil
		database: 	nil
		username: 	nil
		password: 	nil
		isLocal: 	nil
		location: 	nil


WARenderPhaseContinuation>>processRendering:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aResponse: 	a WABufferedResponse status: 200 message: 'OK'
		document: 	a WAHtmlDocument
		actionContinuation: 	a WACallbackProcessingActionContinuation
		renderContext: 	a WARenderContext
		actionUrl: 	/admin?_s=qr1zzT0hxZ1H_6fS&_k=uZ3BwkNPW0Bn1Y8a
		actionBaseUrl: 	/admin?_s=qr1zzT0hxZ1H_6fS&_k=uZ3BwkNPW0Bn1Y8a
		htmlRoot: 	a WAHtmlRoot
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin'
		response: 	a WABufferedResponse status: 200 message: 'OK'
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


WARequestContext>>respond:
	Receiver: a WARequestContext url: '/admin'
	Arguments and temporary variables: 
		aBlock: 	[ :response | self processRendering: response ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WARenderPhaseContinuation a WAInitialRenderLoo...etc...
		request: 	a WARequest method: GET uri: /admin version: HTTP/1.1
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	a GRSmallDictionary()


WARenderPhaseContinuation(WASessionContinuation)>>respond:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[ :response | self processRendering: response ]
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


WARenderPhaseContinuation>>handleFiltered:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin'
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin'
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


BlockClosure>>on:do:
	Receiver: [ self filter handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
		handlerAction: 	[ :notification | notification resume: anObject ]
	Receiver's instance variables: 
		outerContext: 	WARenderPhaseContinuation(WARequestHandler)>>handle:
		startpc: 	32
		numArgs: 	0


WACurrentRequestContext class(WADynamicVariable class)>>use:during:
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 
		anObject: 	a WARequestContext url: '/admin'
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin'
	Arguments and temporary variables: 
		aRequestHandler: 	a WARenderPhaseContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WARenderPhaseContinuation a WAInitialRenderLoo...etc...
		request: 	a WARequest method: GET uri: /admin version: HTTP/1.1
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	a GRSmallDictionary()


BlockClosure>>ensure:
	Receiver: [ WACurrentRequestContext use: self during: aBlock ]
	Arguments and temporary variables: 
		aBlock: 	[ handlers removeFirst ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WARequestContext>>push:during:
		startpc: 	42
		numArgs: 	0


WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin'
	Arguments and temporary variables: 
		aRequestHandler: 	a WARenderPhaseContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WARenderPhaseContinuation a WAInitialRenderLoo...etc...
		request: 	a WARequest method: GET uri: /admin version: HTTP/1.1
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	a GRSmallDictionary()


WARenderPhaseContinuation(WARequestHandler)>>handle:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin'
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot



--- The full stack ---
CWAdminComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWAdminComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWAdminComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
WARequestContextNotFound
11 May 2017 6:44:51.231117 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

WACurrentRequestContext class>>defaultValue
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


WACurrentRequestContext(WADynamicVariable)>>defaultAction
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a CWAdminComponent
		signalContext: 	WACurrentRequestContext(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
	Receiver's instance variables: 
nil

WACurrentRequestContext(Exception)>>signal
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a CWAdminComponent
		signalContext: 	WACurrentRequestContext(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil


WACurrentRequestContext class(Exception class)>>signal
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


WACurrentRequestContext class(WADynamicVariable class)>>value
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


CWAdminComponent(WAObject)>>requestContext
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	nil
		database: 	nil
		username: 	nil
		password: 	nil
		isLocal: 	nil
		location: 	nil


CWAdminComponent>>DoItIn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		ThisContext: 	CWAdminComponent>>renderContentOn:
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	nil
		database: 	nil
		username: 	nil
		password: 	nil
		isLocal: 	nil
		location: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'self requestContext inspect.'
		itsSelection: 	a Text for 'self requestContext inspect.'
		itsSelectionString: 	'self requestContext inspect.'
	Receiver's instance variables: 
		ast: 	DoItIn: ThisContext
	^ self requestContext inspect
		source: 	a ReadStream
		context: 	CWAdminComponent>>renderContentOn:
		receiver: 	a CWAdminComponent
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	a CWAdminComponent
		ctxt: 	CWAdminComponent>>renderContentOn:
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(668352768)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(668352768)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoMethodRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(869657088)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(668352768)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1100@297)
		owner: 	a TransformWithLayoutMorph(595784448)
		submorphs: 	an Array(a RubCursor(183495936) a RubPrimarySelectionMorph(104385664...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (232097792) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(709128704)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(183495936)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(1041318912))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoMethodRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(869657088)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(303211008))
		viewBox: 	(0@0) corner: (1680@922)
		canvas: 	a FormCanvas on: DisplayScreen(1680x922x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(411866880))(a SearchMorp...etc...
		lastStepTime: 	258827
		lastStepMessage: 	nil
		lastCycleTime: 	258847
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(183495936)))
		lastAlarmTime: 	258827
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1680@922)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(804941056) a GLMSystemWindow(69668352) a Nau...etc...
		fullBounds: 	(0@0) corner: (1680@922)
		color: 	(Color r: 0.96 g: 0.787 b: 0.787 alpha: 1.0)
		extension: 	a MorphExtension (649908480) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(303211008))
		viewBox: 	(0@0) corner: (1680@922)
		canvas: 	a FormCanvas on: DisplayScreen(1680x922x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(411866880))(a SearchMorp...etc...
		lastStepTime: 	258827
		lastStepMessage: 	nil
		lastCycleTime: 	258847
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(183495936)))
		lastAlarmTime: 	258827
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(303211008))
		viewBox: 	(0@0) corner: (1680@922)
		canvas: 	a FormCanvas on: DisplayScreen(1680x922x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(411866880))(a SearchMorp...etc...
		lastStepTime: 	258827
		lastStepMessage: 	nil
		lastCycleTime: 	258847
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(183495936)))
		lastAlarmTime: 	258827
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1680@922)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(804941056) a GLMSystemWindow(69668352) a Nau...etc...
		fullBounds: 	(0@0) corner: (1680@922)
		color: 	(Color r: 0.96 g: 0.787 b: 0.787 alpha: 1.0)
		extension: 	a MorphExtension (649908480) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


[ [ World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
WACurrentRequestContext class>>defaultValue
WACurrentRequestContext(WADynamicVariable)>>defaultAction
UndefinedObject>>handleSignal:
WACurrentRequestContext(Exception)>>signal
WACurrentRequestContext class(Exception class)>>signal
WACurrentRequestContext class(WADynamicVariable class)>>value
CWAdminComponent(WAObject)>>requestContext
CWAdminComponent>>DoItIn:
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ [ World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of UndefinedObject are not indexable
11 May 2017 6:59:29.268132 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

UndefinedObject(Object)>>error:
	Receiver: nil
	Arguments and temporary variables: 
		aString: 	'Instances of UndefinedObject are not indexable'
	Receiver's instance variables: 
nil

UndefinedObject(Object)>>errorNotIndexable
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

UndefinedObject(Object)>>size
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: 'http://localhost:'
	Arguments and temporary variables: 
		start: 	18
		stop: 	17
		replacementCollection: 	nil
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
'http://localhost:'

ByteString(SequenceableCollection)>>,
	Receiver: 'http://localhost:'
	Arguments and temporary variables: 
		otherCollection: 	nil
	Receiver's instance variables: 
'http://localhost:'

CWAdminComponent>>normalizeLocation:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aUrlString: 	'http://localhost/self'
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'http://localhost/self'


CWAdminComponent>>save
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'http://localhost/self'


[ self save ] in CWAdminComponent>>renderButtonsOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'http://localhost/self'


BlockClosure>>valueWithPossibleArguments:
	Receiver: [ self save ]
	Arguments and temporary variables: 
		anArray: 	#('Save changes')
		args: 	#()
	Receiver's instance variables: 
		outerContext: 	CWAdminComponent>>renderButtonsOn:
		startpc: 	52
		numArgs: 	0


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	nil
	Receiver's instance variables: 
		key: 	'1'
		block: 	[ self debug ]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#(nil)
	Receiver's instance variables: 
		key: 	'1'
		block: 	[ self debug ]


[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
		set: 	a Set(a WAActionCallback)
		fields: 	a WAMergedRequestFields
		callback: 	a WAActionCallback
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	18


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAActionCallback)
	Arguments and temporary variables: 
		aBlock: 	[ :callback | callback evaluateWithFieldValues: (fields allAt: callback...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a WAActionCallback)

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
		set: 	a Set(a WAActionCallback)
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	18


WACallbackProcessingActionContinuation>>basicPerformAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self basicPerformAction ]
	Arguments and temporary variables: 
		exception: 	a WAWalkbackErrorHandler
		handlerAction: 	[ :exception | 
[ self handleException: exception ]
	on: Error
	...etc...
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WAActionPhaseContinuation)...etc...
		startpc: 	30
		numArgs: 	0


WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
	Receiver: a WAWalkbackErrorHandler
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
	Receiver's instance variables: 
		requestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd3...etc...


[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ currentHandler handleExceptionsDuring: aBlock ]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[ :n |  ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARenderLoopContinuation)>...etc...
		startpc: 	61
		numArgs: 	0


WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>ensure:
	Receiver: [ super performAction ]
	Arguments and temporary variables: 
		aBlock: 	[ self request isXmlHttpRequest
	ifTrue: [ self captureState ] ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation>>performAction
		startpc: 	41
		numArgs: 	0


WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self filter handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
		handlerAction: 	[ :notification | notification resume: anObject ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARequestHandler)>>handle:...etc...
		startpc: 	32
		numArgs: 	0


WACurrentRequestContext class(WADynamicVariable class)>>use:during:
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 
		anObject: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd3CR-P-w...etc...
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd3CR-P-wZrOg'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: GET uri: /admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd3CR-...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


BlockClosure>>ensure:
	Receiver: [ WACurrentRequestContext use: self during: aBlock ]
	Arguments and temporary variables: 
		aBlock: 	[ handlers removeFirst ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WARequestContext>>push:during:
		startpc: 	42
		numArgs: 	0


WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd3CR-P-wZrOg'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: GET uri: /admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd3CR-...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ super handle: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[ :err | self requestContext redirectTo: self application url ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WASessionContinuation)>>ha...etc...
		startpc: 	39
		numArgs: 	0


WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ super handle: aRequestContext ]
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WASession>>handleFiltered:
	Receiver: a WASession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
		continationKey: 	'kvztd3CR-P-wZrOg'
		continuation: 	a WACallbackProcessingActionContinuation
		fields: 	a WAMergedRequestFields
		documentHandlerKey: 	nil
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WAHashCache
		properties: 	a GRSmallDictionary(#presenter->a CWAdminComponent)
		documentHandlers: 	nil
		key: 	'aauf1fNKYgGMb2CI'


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1136857
		previousTiming: 	2



--- The full stack ---
UndefinedObject(Object)>>error:
UndefinedObject(Object)>>errorNotIndexable
UndefinedObject(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
CWAdminComponent>>normalizeLocation:
CWAdminComponent>>save
[ self save ] in CWAdminComponent>>renderButtonsOn:
BlockClosure>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
WACallbackProcessingActionContinuation>>basicPerformAction
[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
BlockClosure>>ensure:
WACallbackProcessingActionContinuation>>performAction
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
WASession>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handleKeyed:with:context:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of UndefinedObject are not indexable
11 May 2017 7:01:19.08488 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

UndefinedObject(Object)>>error:
	Receiver: nil
	Arguments and temporary variables: 
		aString: 	'Instances of UndefinedObject are not indexable'
	Receiver's instance variables: 
nil

UndefinedObject(Object)>>errorNotIndexable
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

UndefinedObject(Object)>>size
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: 'http://localhost:'
	Arguments and temporary variables: 
		start: 	18
		stop: 	17
		replacementCollection: 	nil
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
'http://localhost:'

ByteString(SequenceableCollection)>>,
	Receiver: 'http://localhost:'
	Arguments and temporary variables: 
		otherCollection: 	nil
	Receiver's instance variables: 
'http://localhost:'

CWAdminComponent>>normalizeLocation:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aUrlString: 	'http://localhost/self'
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'http://localhost/self'


CWAdminComponent>>save
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'http://localhost/self'


[ self save ] in CWAdminComponent>>renderButtonsOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'http://localhost/self'


BlockClosure>>valueWithPossibleArguments:
	Receiver: [ self save ]
	Arguments and temporary variables: 
		anArray: 	#('Save changes')
		args: 	#()
	Receiver's instance variables: 
		outerContext: 	CWAdminComponent>>renderButtonsOn:
		startpc: 	52
		numArgs: 	0


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	nil
	Receiver's instance variables: 
		key: 	'1'
		block: 	[ self debug ]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#(nil)
	Receiver's instance variables: 
		key: 	'1'
		block: 	[ self debug ]


[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
		set: 	a Set(a WAActionCallback)
		fields: 	a WAMergedRequestFields
		callback: 	a WAActionCallback
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	18


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAActionCallback)
	Arguments and temporary variables: 
		aBlock: 	[ :callback | callback evaluateWithFieldValues: (fields allAt: callback...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a WAActionCallback)

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
		set: 	a Set(a WAActionCallback)
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	18


WACallbackProcessingActionContinuation>>basicPerformAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self basicPerformAction ]
	Arguments and temporary variables: 
		exception: 	a WAWalkbackErrorHandler
		handlerAction: 	[ :exception | 
[ self handleException: exception ]
	on: Error
	...etc...
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WAActionPhaseContinuation)...etc...
		startpc: 	30
		numArgs: 	0


WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
	Receiver: a WAWalkbackErrorHandler
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
	Receiver's instance variables: 
		requestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd3...etc...


[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ currentHandler handleExceptionsDuring: aBlock ]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[ :n |  ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARenderLoopContinuation)>...etc...
		startpc: 	61
		numArgs: 	0


WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>ensure:
	Receiver: [ super performAction ]
	Arguments and temporary variables: 
		aBlock: 	[ self request isXmlHttpRequest
	ifTrue: [ self captureState ] ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation>>performAction
		startpc: 	41
		numArgs: 	0


WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self filter handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
		handlerAction: 	[ :notification | notification resume: anObject ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARequestHandler)>>handle:...etc...
		startpc: 	32
		numArgs: 	0


WACurrentRequestContext class(WADynamicVariable class)>>use:during:
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 
		anObject: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd3CR-P-w...etc...
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd3CR-P-wZrOg'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: GET uri: /admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd3CR-...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


BlockClosure>>ensure:
	Receiver: [ WACurrentRequestContext use: self during: aBlock ]
	Arguments and temporary variables: 
		aBlock: 	[ handlers removeFirst ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WARequestContext>>push:during:
		startpc: 	42
		numArgs: 	0


WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd3CR-P-wZrOg'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: GET uri: /admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd3CR-...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ super handle: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[ :err | self requestContext redirectTo: self application url ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WASessionContinuation)>>ha...etc...
		startpc: 	39
		numArgs: 	0


WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ super handle: aRequestContext ]
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WASession>>handleFiltered:
	Receiver: a WASession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
		continationKey: 	'kvztd3CR-P-wZrOg'
		continuation: 	a WACallbackProcessingActionContinuation
		fields: 	a WAMergedRequestFields
		documentHandlerKey: 	nil
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WAHashCache
		properties: 	a GRSmallDictionary(#presenter->a CWAdminComponent)
		documentHandlers: 	nil
		key: 	'aauf1fNKYgGMb2CI'


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?1&_s=aauf1fNKYgGMb2CI&_k=kvztd...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1246604
		previousTiming: 	109727



--- The full stack ---
UndefinedObject(Object)>>error:
UndefinedObject(Object)>>errorNotIndexable
UndefinedObject(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
CWAdminComponent>>normalizeLocation:
CWAdminComponent>>save
[ self save ] in CWAdminComponent>>renderButtonsOn:
BlockClosure>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
WACallbackProcessingActionContinuation>>basicPerformAction
[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
BlockClosure>>ensure:
WACallbackProcessingActionContinuation>>performAction
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
WASession>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handleKeyed:with:context:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
11 May 2017 7:09:25.071302 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

CWAdminComponent>>save
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'http://localhost:8888/'


[ self save ] in CWAdminComponent>>renderButtonsOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'http://localhost:8888/'


BlockClosure>>valueWithPossibleArguments:
	Receiver: [ self save ]
	Arguments and temporary variables: 
		anArray: 	#('Save changes')
		args: 	#()
	Receiver's instance variables: 
		outerContext: 	CWAdminComponent>>renderButtonsOn:
		startpc: 	52
		numArgs: 	0


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	'Save changes'
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#('Save changes')
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
		set: 	a Set(a WAValueCallback a WAValueCallback a WAValueCallback a WAActionCall...etc...
		fields: 	a WAMergedRequestFields
		callback: 	a WAActionCallback
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :callback | callback evaluateWithFieldValues: (fields allAt: callback...etc...
		index: 	7
	Receiver's instance variables: 
an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
		set: 	a Set(a WAValueCallback a WAValueCallback a WAValueCallback a WAActionCall...etc...
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


WACallbackProcessingActionContinuation>>basicPerformAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self basicPerformAction ]
	Arguments and temporary variables: 
		exception: 	a WAWalkbackErrorHandler
		handlerAction: 	[ :exception | 
[ self handleException: exception ]
	on: Error
	...etc...
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WAActionPhaseContinuation)...etc...
		startpc: 	30
		numArgs: 	0


WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
	Receiver: a WAWalkbackErrorHandler
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
	Receiver's instance variables: 
		requestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTw...etc...


[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ currentHandler handleExceptionsDuring: aBlock ]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[ :n |  ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARenderLoopContinuation)>...etc...
		startpc: 	61
		numArgs: 	0


WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>ensure:
	Receiver: [ super performAction ]
	Arguments and temporary variables: 
		aBlock: 	[ self request isXmlHttpRequest
	ifTrue: [ self captureState ] ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation>>performAction
		startpc: 	41
		numArgs: 	0


WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self filter handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
		handlerAction: 	[ :notification | notification resume: anObject ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARequestHandler)>>handle:...etc...
		startpc: 	32
		numArgs: 	0


WACurrentRequestContext class(WADynamicVariable class)>>use:during:
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 
		anObject: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO4vMX...etc...
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO4vMXHy'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


BlockClosure>>ensure:
	Receiver: [ WACurrentRequestContext use: self during: aBlock ]
	Arguments and temporary variables: 
		aBlock: 	[ handlers removeFirst ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WARequestContext>>push:during:
		startpc: 	42
		numArgs: 	0


WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO4vMXHy'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ super handle: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[ :err | self requestContext redirectTo: self application url ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WASessionContinuation)>>ha...etc...
		startpc: 	39
		numArgs: 	0


WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ super handle: aRequestContext ]
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WASession>>handleFiltered:
	Receiver: a WASession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
		continationKey: 	'Bul2OVTwzO4vMXHy'
		continuation: 	a WACallbackProcessingActionContinuation
		fields: 	a WAMergedRequestFields
		documentHandlerKey: 	nil
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WAHashCache
		properties: 	a GRSmallDictionary(#presenter->a CWAdminComponent)
		documentHandlers: 	nil
		key: 	'orB-26pkkUoms4Sb'


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1732674
		previousTiming: 	2


[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1732674
		previousTiming: 	2


BlockClosure>>ensure:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		aBlock: 	[ previousTiming := self currentTiming ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1732674
		previousTiming: 	2


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :notification | self deprecated: notification ]
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	50
		numArgs: 	0



--- The full stack ---
CWAdminComponent>>save
[ self save ] in CWAdminComponent>>renderButtonsOn:
BlockClosure>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
WACallbackProcessingActionContinuation>>basicPerformAction
[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
BlockClosure>>ensure:
WACallbackProcessingActionContinuation>>performAction
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
WASession>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handleKeyed:with:context:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
11 May 2017 7:10:23.564695 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

CWAdminComponent>>save
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'http://localhost:8888/'


[ self save ] in CWAdminComponent>>renderButtonsOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'http://localhost:8888/'


BlockClosure>>valueWithPossibleArguments:
	Receiver: [ self save ]
	Arguments and temporary variables: 
		anArray: 	#('Save changes')
		args: 	#()
	Receiver's instance variables: 
		outerContext: 	CWAdminComponent>>renderButtonsOn:
		startpc: 	52
		numArgs: 	0


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	'Save changes'
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#('Save changes')
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
		set: 	a Set(a WAValueCallback a WAValueCallback a WAValueCallback a WAActionCall...etc...
		fields: 	a WAMergedRequestFields
		callback: 	a WAActionCallback
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :callback | callback evaluateWithFieldValues: (fields allAt: callback...etc...
		index: 	7
	Receiver's instance variables: 
an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
		set: 	a Set(a WAValueCallback a WAValueCallback a WAValueCallback a WAActionCall...etc...
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


WACallbackProcessingActionContinuation>>basicPerformAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self basicPerformAction ]
	Arguments and temporary variables: 
		exception: 	a WAWalkbackErrorHandler
		handlerAction: 	[ :exception | 
[ self handleException: exception ]
	on: Error
	...etc...
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WAActionPhaseContinuation)...etc...
		startpc: 	30
		numArgs: 	0


WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
	Receiver: a WAWalkbackErrorHandler
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
	Receiver's instance variables: 
		requestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTw...etc...


[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ currentHandler handleExceptionsDuring: aBlock ]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[ :n |  ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARenderLoopContinuation)>...etc...
		startpc: 	61
		numArgs: 	0


WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>ensure:
	Receiver: [ super performAction ]
	Arguments and temporary variables: 
		aBlock: 	[ self request isXmlHttpRequest
	ifTrue: [ self captureState ] ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation>>performAction
		startpc: 	41
		numArgs: 	0


WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self filter handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
		handlerAction: 	[ :notification | notification resume: anObject ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARequestHandler)>>handle:...etc...
		startpc: 	32
		numArgs: 	0


WACurrentRequestContext class(WADynamicVariable class)>>use:during:
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 
		anObject: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO4vMX...etc...
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO4vMXHy'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


BlockClosure>>ensure:
	Receiver: [ WACurrentRequestContext use: self during: aBlock ]
	Arguments and temporary variables: 
		aBlock: 	[ handlers removeFirst ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WARequestContext>>push:during:
		startpc: 	42
		numArgs: 	0


WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO4vMXHy'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ super handle: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[ :err | self requestContext redirectTo: self application url ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WASessionContinuation)>>ha...etc...
		startpc: 	39
		numArgs: 	0


WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ super handle: aRequestContext ]
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WASession>>handleFiltered:
	Receiver: a WASession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
		continationKey: 	'Bul2OVTwzO4vMXHy'
		continuation: 	a WACallbackProcessingActionContinuation
		fields: 	a WAMergedRequestFields
		documentHandlerKey: 	nil
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WAHashCache
		properties: 	a GRSmallDictionary(#presenter->a CWAdminComponent)
		documentHandlers: 	nil
		key: 	'orB-26pkkUoms4Sb'


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1791184
		previousTiming: 	58508


[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1791184
		previousTiming: 	58508


BlockClosure>>ensure:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		aBlock: 	[ previousTiming := self currentTiming ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1791184
		previousTiming: 	58508


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :notification | self deprecated: notification ]
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	50
		numArgs: 	0



--- The full stack ---
CWAdminComponent>>save
[ self save ] in CWAdminComponent>>renderButtonsOn:
BlockClosure>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
WACallbackProcessingActionContinuation>>basicPerformAction
[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
BlockClosure>>ensure:
WACallbackProcessingActionContinuation>>performAction
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
WASession>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handleKeyed:with:context:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
11 May 2017 7:10:26.032267 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

CWAdminComponent>>save
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'http://localhost:8888/'


[ self save ] in CWAdminComponent>>renderButtonsOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'http://localhost:8888/'


BlockClosure>>valueWithPossibleArguments:
	Receiver: [ self save ]
	Arguments and temporary variables: 
		anArray: 	#('Save changes')
		args: 	#()
	Receiver's instance variables: 
		outerContext: 	CWAdminComponent>>renderButtonsOn:
		startpc: 	52
		numArgs: 	0


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	'Save changes'
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#('Save changes')
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
		set: 	a Set(a WAValueCallback a WAValueCallback a WAValueCallback a WAActionCall...etc...
		fields: 	a WAMergedRequestFields
		callback: 	a WAActionCallback
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :callback | callback evaluateWithFieldValues: (fields allAt: callback...etc...
		index: 	7
	Receiver's instance variables: 
an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
		set: 	a Set(a WAValueCallback a WAValueCallback a WAValueCallback a WAActionCall...etc...
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


WACallbackProcessingActionContinuation>>basicPerformAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self basicPerformAction ]
	Arguments and temporary variables: 
		exception: 	a WAWalkbackErrorHandler
		handlerAction: 	[ :exception | 
[ self handleException: exception ]
	on: Error
	...etc...
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WAActionPhaseContinuation)...etc...
		startpc: 	30
		numArgs: 	0


WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
	Receiver: a WAWalkbackErrorHandler
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
	Receiver's instance variables: 
		requestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTw...etc...


[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ currentHandler handleExceptionsDuring: aBlock ]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[ :n |  ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARenderLoopContinuation)>...etc...
		startpc: 	61
		numArgs: 	0


WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>ensure:
	Receiver: [ super performAction ]
	Arguments and temporary variables: 
		aBlock: 	[ self request isXmlHttpRequest
	ifTrue: [ self captureState ] ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation>>performAction
		startpc: 	41
		numArgs: 	0


WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self filter handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
		handlerAction: 	[ :notification | notification resume: anObject ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARequestHandler)>>handle:...etc...
		startpc: 	32
		numArgs: 	0


WACurrentRequestContext class(WADynamicVariable class)>>use:during:
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 
		anObject: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO4vMX...etc...
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO4vMXHy'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


BlockClosure>>ensure:
	Receiver: [ WACurrentRequestContext use: self during: aBlock ]
	Arguments and temporary variables: 
		aBlock: 	[ handlers removeFirst ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WARequestContext>>push:during:
		startpc: 	42
		numArgs: 	0


WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO4vMXHy'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ super handle: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[ :err | self requestContext redirectTo: self application url ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WASessionContinuation)>>ha...etc...
		startpc: 	39
		numArgs: 	0


WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ super handle: aRequestContext ]
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WASession>>handleFiltered:
	Receiver: a WASession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
		continationKey: 	'Bul2OVTwzO4vMXHy'
		continuation: 	a WACallbackProcessingActionContinuation
		fields: 	a WAMergedRequestFields
		documentHandlerKey: 	nil
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WAHashCache
		properties: 	a GRSmallDictionary(#presenter->a CWAdminComponent)
		documentHandlers: 	nil
		key: 	'orB-26pkkUoms4Sb'


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1793650
		previousTiming: 	2464


[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1793650
		previousTiming: 	2464


BlockClosure>>ensure:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		aBlock: 	[ previousTiming := self currentTiming ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1793650
		previousTiming: 	2464


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :notification | self deprecated: notification ]
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	50
		numArgs: 	0



--- The full stack ---
CWAdminComponent>>save
[ self save ] in CWAdminComponent>>renderButtonsOn:
BlockClosure>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
WACallbackProcessingActionContinuation>>basicPerformAction
[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
BlockClosure>>ensure:
WACallbackProcessingActionContinuation>>performAction
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
WASession>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handleKeyed:with:context:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
11 May 2017 7:10:26.989253 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

CWAdminComponent>>save
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'localhost:9000'


[ self save ] in CWAdminComponent>>renderButtonsOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'localhost:9000'


BlockClosure>>valueWithPossibleArguments:
	Receiver: [ self save ]
	Arguments and temporary variables: 
		anArray: 	#('Save changes')
		args: 	#()
	Receiver's instance variables: 
		outerContext: 	CWAdminComponent>>renderButtonsOn:
		startpc: 	52
		numArgs: 	0


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	'Save changes'
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#('Save changes')
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
		set: 	a Set(a WAValueCallback a WAValueCallback a WAValueCallback a WAActionCall...etc...
		fields: 	a WAMergedRequestFields
		callback: 	a WAActionCallback
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :callback | callback evaluateWithFieldValues: (fields allAt: callback...etc...
		index: 	7
	Receiver's instance variables: 
an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
		set: 	a Set(a WAValueCallback a WAValueCallback a WAValueCallback a WAActionCall...etc...
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


WACallbackProcessingActionContinuation>>basicPerformAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self basicPerformAction ]
	Arguments and temporary variables: 
		exception: 	a WAWalkbackErrorHandler
		handlerAction: 	[ :exception | 
[ self handleException: exception ]
	on: Error
	...etc...
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WAActionPhaseContinuation)...etc...
		startpc: 	30
		numArgs: 	0


WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
	Receiver: a WAWalkbackErrorHandler
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
	Receiver's instance variables: 
		requestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTw...etc...


[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ currentHandler handleExceptionsDuring: aBlock ]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[ :n |  ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARenderLoopContinuation)>...etc...
		startpc: 	61
		numArgs: 	0


WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>ensure:
	Receiver: [ super performAction ]
	Arguments and temporary variables: 
		aBlock: 	[ self request isXmlHttpRequest
	ifTrue: [ self captureState ] ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation>>performAction
		startpc: 	41
		numArgs: 	0


WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self filter handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
		handlerAction: 	[ :notification | notification resume: anObject ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARequestHandler)>>handle:...etc...
		startpc: 	32
		numArgs: 	0


WACurrentRequestContext class(WADynamicVariable class)>>use:during:
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 
		anObject: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO4vMX...etc...
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO4vMXHy'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


BlockClosure>>ensure:
	Receiver: [ WACurrentRequestContext use: self during: aBlock ]
	Arguments and temporary variables: 
		aBlock: 	[ handlers removeFirst ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WARequestContext>>push:during:
		startpc: 	42
		numArgs: 	0


WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO4vMXHy'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVTwzO...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ super handle: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[ :err | self requestContext redirectTo: self application url ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WASessionContinuation)>>ha...etc...
		startpc: 	39
		numArgs: 	0


WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ super handle: aRequestContext ]
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WASession>>handleFiltered:
	Receiver: a WASession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
		continationKey: 	'Bul2OVTwzO4vMXHy'
		continuation: 	a WACallbackProcessingActionContinuation
		fields: 	a WAMergedRequestFields
		documentHandlerKey: 	nil
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WAHashCache
		properties: 	a GRSmallDictionary(#presenter->a CWAdminComponent)
		documentHandlers: 	nil
		key: 	'orB-26pkkUoms4Sb'


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1794610
		previousTiming: 	956


[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1794610
		previousTiming: 	956


BlockClosure>>ensure:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		aBlock: 	[ previousTiming := self currentTiming ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1794610
		previousTiming: 	956


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=Bul2OVT...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :notification | self deprecated: notification ]
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	50
		numArgs: 	0



--- The full stack ---
CWAdminComponent>>save
[ self save ] in CWAdminComponent>>renderButtonsOn:
BlockClosure>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
WACallbackProcessingActionContinuation>>basicPerformAction
[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
BlockClosure>>ensure:
WACallbackProcessingActionContinuation>>performAction
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
WASession>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handleKeyed:with:context:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
11 May 2017 7:10:46.375639 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

CWAdminComponent>>save
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	''


[ self save ] in CWAdminComponent>>renderButtonsOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	''


BlockClosure>>valueWithPossibleArguments:
	Receiver: [ self save ]
	Arguments and temporary variables: 
		anArray: 	#('Save changes')
		args: 	#()
	Receiver's instance variables: 
		outerContext: 	CWAdminComponent>>renderButtonsOn:
		startpc: 	52
		numArgs: 	0


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	'Save changes'
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#('Save changes')
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
		set: 	a Set(a WAValueCallback a WAActionCallback a WAValueCallback a WADispatchC...etc...
		fields: 	a WAMergedRequestFields
		callback: 	a WAActionCallback
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :callback | callback evaluateWithFieldValues: (fields allAt: callback...etc...
		index: 	7
	Receiver's instance variables: 
an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
		set: 	a Set(a WAValueCallback a WAActionCallback a WAValueCallback a WADispatchC...etc...
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


WACallbackProcessingActionContinuation>>basicPerformAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self basicPerformAction ]
	Arguments and temporary variables: 
		exception: 	a WAWalkbackErrorHandler
		handlerAction: 	[ :exception | 
[ self handleException: exception ]
	on: Error
	...etc...
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WAActionPhaseContinuation)...etc...
		startpc: 	30
		numArgs: 	0


WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
	Receiver: a WAWalkbackErrorHandler
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
	Receiver's instance variables: 
		requestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5...etc...


[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ currentHandler handleExceptionsDuring: aBlock ]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[ :n |  ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARenderLoopContinuation)>...etc...
		startpc: 	61
		numArgs: 	0


WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>ensure:
	Receiver: [ super performAction ]
	Arguments and temporary variables: 
		aBlock: 	[ self request isXmlHttpRequest
	ifTrue: [ self captureState ] ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation>>performAction
		startpc: 	41
		numArgs: 	0


WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self filter handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
		handlerAction: 	[ :notification | notification resume: anObject ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARequestHandler)>>handle:...etc...
		startpc: 	32
		numArgs: 	0


WACurrentRequestContext class(WADynamicVariable class)>>use:during:
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 
		anObject: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5zzd25F...etc...
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5zzd25FH4'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5zz...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


BlockClosure>>ensure:
	Receiver: [ WACurrentRequestContext use: self during: aBlock ]
	Arguments and temporary variables: 
		aBlock: 	[ handlers removeFirst ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WARequestContext>>push:during:
		startpc: 	42
		numArgs: 	0


WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5zzd25FH4'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5zz...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ super handle: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[ :err | self requestContext redirectTo: self application url ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WASessionContinuation)>>ha...etc...
		startpc: 	39
		numArgs: 	0


WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ super handle: aRequestContext ]
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WASession>>handleFiltered:
	Receiver: a WASession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
		continationKey: 	'09KYkRv5zzd25FH4'
		continuation: 	a WACallbackProcessingActionContinuation
		fields: 	a WAMergedRequestFields
		documentHandlerKey: 	nil
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WAHashCache
		properties: 	a GRSmallDictionary(#presenter->a CWAdminComponent)
		documentHandlers: 	nil
		key: 	'orB-26pkkUoms4Sb'


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1813997
		previousTiming: 	4


[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1813997
		previousTiming: 	4


BlockClosure>>ensure:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		aBlock: 	[ previousTiming := self currentTiming ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1813997
		previousTiming: 	4


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :notification | self deprecated: notification ]
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	50
		numArgs: 	0



--- The full stack ---
CWAdminComponent>>save
[ self save ] in CWAdminComponent>>renderButtonsOn:
BlockClosure>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
WACallbackProcessingActionContinuation>>basicPerformAction
[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
BlockClosure>>ensure:
WACallbackProcessingActionContinuation>>performAction
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
WASession>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handleKeyed:with:context:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
11 May 2017 7:10:58.528014 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

CWAdminComponent>>save
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	''


[ self save ] in CWAdminComponent>>renderButtonsOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	''


BlockClosure>>valueWithPossibleArguments:
	Receiver: [ self save ]
	Arguments and temporary variables: 
		anArray: 	#('Save changes')
		args: 	#()
	Receiver's instance variables: 
		outerContext: 	CWAdminComponent>>renderButtonsOn:
		startpc: 	52
		numArgs: 	0


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	'Save changes'
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#('Save changes')
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
		set: 	a Set(a WAValueCallback a WAActionCallback a WAValueCallback a WADispatchC...etc...
		fields: 	a WAMergedRequestFields
		callback: 	a WAActionCallback
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :callback | callback evaluateWithFieldValues: (fields allAt: callback...etc...
		index: 	7
	Receiver's instance variables: 
an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
		set: 	a Set(a WAValueCallback a WAActionCallback a WAValueCallback a WADispatchC...etc...
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


WACallbackProcessingActionContinuation>>basicPerformAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self basicPerformAction ]
	Arguments and temporary variables: 
		exception: 	a WAWalkbackErrorHandler
		handlerAction: 	[ :exception | 
[ self handleException: exception ]
	on: Error
	...etc...
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WAActionPhaseContinuation)...etc...
		startpc: 	30
		numArgs: 	0


WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
	Receiver: a WAWalkbackErrorHandler
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
	Receiver's instance variables: 
		requestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5...etc...


[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ currentHandler handleExceptionsDuring: aBlock ]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[ :n |  ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARenderLoopContinuation)>...etc...
		startpc: 	61
		numArgs: 	0


WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>ensure:
	Receiver: [ super performAction ]
	Arguments and temporary variables: 
		aBlock: 	[ self request isXmlHttpRequest
	ifTrue: [ self captureState ] ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation>>performAction
		startpc: 	41
		numArgs: 	0


WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self filter handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
		handlerAction: 	[ :notification | notification resume: anObject ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARequestHandler)>>handle:...etc...
		startpc: 	32
		numArgs: 	0


WACurrentRequestContext class(WADynamicVariable class)>>use:during:
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 
		anObject: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5zzd25F...etc...
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5zzd25FH4'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5zz...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


BlockClosure>>ensure:
	Receiver: [ WACurrentRequestContext use: self during: aBlock ]
	Arguments and temporary variables: 
		aBlock: 	[ handlers removeFirst ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WARequestContext>>push:during:
		startpc: 	42
		numArgs: 	0


WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5zzd25FH4'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5zz...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ super handle: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[ :err | self requestContext redirectTo: self application url ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WASessionContinuation)>>ha...etc...
		startpc: 	39
		numArgs: 	0


WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ super handle: aRequestContext ]
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WASession>>handleFiltered:
	Receiver: a WASession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
		continationKey: 	'09KYkRv5zzd25FH4'
		continuation: 	a WACallbackProcessingActionContinuation
		fields: 	a WAMergedRequestFields
		documentHandlerKey: 	nil
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WAHashCache
		properties: 	a GRSmallDictionary(#presenter->a CWAdminComponent)
		documentHandlers: 	nil
		key: 	'orB-26pkkUoms4Sb'


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1826135
		previousTiming: 	12136


[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1826135
		previousTiming: 	12136


BlockClosure>>ensure:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		aBlock: 	[ previousTiming := self currentTiming ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1826135
		previousTiming: 	12136


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :notification | self deprecated: notification ]
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	50
		numArgs: 	0



--- The full stack ---
CWAdminComponent>>save
[ self save ] in CWAdminComponent>>renderButtonsOn:
BlockClosure>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
WACallbackProcessingActionContinuation>>basicPerformAction
[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
BlockClosure>>ensure:
WACallbackProcessingActionContinuation>>performAction
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
WASession>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handleKeyed:with:context:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
11 May 2017 7:10:59.568543 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

CWAdminComponent>>save
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'localhost:9000'


[ self save ] in CWAdminComponent>>renderButtonsOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'localhost:9000'


BlockClosure>>valueWithPossibleArguments:
	Receiver: [ self save ]
	Arguments and temporary variables: 
		anArray: 	#('Save changes')
		args: 	#()
	Receiver's instance variables: 
		outerContext: 	CWAdminComponent>>renderButtonsOn:
		startpc: 	52
		numArgs: 	0


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	'Save changes'
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#('Save changes')
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
		set: 	a Set(a WAValueCallback a WAActionCallback a WAValueCallback a WADispatchC...etc...
		fields: 	a WAMergedRequestFields
		callback: 	a WAActionCallback
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :callback | callback evaluateWithFieldValues: (fields allAt: callback...etc...
		index: 	7
	Receiver's instance variables: 
an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
		set: 	a Set(a WAValueCallback a WAActionCallback a WAValueCallback a WADispatchC...etc...
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


WACallbackProcessingActionContinuation>>basicPerformAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self basicPerformAction ]
	Arguments and temporary variables: 
		exception: 	a WAWalkbackErrorHandler
		handlerAction: 	[ :exception | 
[ self handleException: exception ]
	on: Error
	...etc...
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WAActionPhaseContinuation)...etc...
		startpc: 	30
		numArgs: 	0


WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
	Receiver: a WAWalkbackErrorHandler
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
	Receiver's instance variables: 
		requestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5...etc...


[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ currentHandler handleExceptionsDuring: aBlock ]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[ :n |  ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARenderLoopContinuation)>...etc...
		startpc: 	61
		numArgs: 	0


WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>ensure:
	Receiver: [ super performAction ]
	Arguments and temporary variables: 
		aBlock: 	[ self request isXmlHttpRequest
	ifTrue: [ self captureState ] ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation>>performAction
		startpc: 	41
		numArgs: 	0


WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self filter handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
		handlerAction: 	[ :notification | notification resume: anObject ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARequestHandler)>>handle:...etc...
		startpc: 	32
		numArgs: 	0


WACurrentRequestContext class(WADynamicVariable class)>>use:during:
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 
		anObject: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5zzd25F...etc...
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5zzd25FH4'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5zz...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


BlockClosure>>ensure:
	Receiver: [ WACurrentRequestContext use: self during: aBlock ]
	Arguments and temporary variables: 
		aBlock: 	[ handlers removeFirst ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WARequestContext>>push:during:
		startpc: 	42
		numArgs: 	0


WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5zzd25FH4'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv5zz...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ super handle: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[ :err | self requestContext redirectTo: self application url ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WASessionContinuation)>>ha...etc...
		startpc: 	39
		numArgs: 	0


WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ super handle: aRequestContext ]
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WASession>>handleFiltered:
	Receiver: a WASession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
		continationKey: 	'09KYkRv5zzd25FH4'
		continuation: 	a WACallbackProcessingActionContinuation
		fields: 	a WAMergedRequestFields
		documentHandlerKey: 	nil
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WAHashCache
		properties: 	a GRSmallDictionary(#presenter->a CWAdminComponent)
		documentHandlers: 	nil
		key: 	'orB-26pkkUoms4Sb'


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1827187
		previousTiming: 	1048


[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1827187
		previousTiming: 	1048


BlockClosure>>ensure:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		aBlock: 	[ previousTiming := self currentTiming ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1827187
		previousTiming: 	1048


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=09KYkRv...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :notification | self deprecated: notification ]
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	50
		numArgs: 	0



--- The full stack ---
CWAdminComponent>>save
[ self save ] in CWAdminComponent>>renderButtonsOn:
BlockClosure>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
WACallbackProcessingActionContinuation>>basicPerformAction
[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
BlockClosure>>ensure:
WACallbackProcessingActionContinuation>>performAction
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
WASession>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handleKeyed:with:context:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
11 May 2017 7:11:49.700813 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

CWAdminComponent>>save
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'localhost:9000'


[ self save ] in CWAdminComponent>>renderButtonsOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		host: 	'localhost'
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'
		isLocal: 	false
		location: 	'localhost:9000'


BlockClosure>>valueWithPossibleArguments:
	Receiver: [ self save ]
	Arguments and temporary variables: 
		anArray: 	#('Save changes')
		args: 	#()
	Receiver's instance variables: 
		outerContext: 	CWAdminComponent>>renderButtonsOn:
		startpc: 	52
		numArgs: 	0


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	'Save changes'
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#('Save changes')
	Receiver's instance variables: 
		key: 	'9'
		block: 	[ self save ]


[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5Pm...etc...
		set: 	a Set(a WAActionCallback a WAValueCallback a WAValueCallback a WAValueCall...etc...
		fields: 	a WAMergedRequestFields
		callback: 	a WAActionCallback
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :callback | callback evaluateWithFieldValues: (fields allAt: callback...etc...
		index: 	7
	Receiver's instance variables: 
an Array(a WAValueCallback a WADispatchCallback a WAValueCallback a WAValueCallback a WAVa...etc...

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5Pm...etc...
		set: 	a Set(a WAActionCallback a WAValueCallback a WAValueCallback a WAValueCall...etc...
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAValueCallback '10'->a WACancelActionCallback '...etc...
		nextKey: 	16


WACallbackProcessingActionContinuation>>basicPerformAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self basicPerformAction ]
	Arguments and temporary variables: 
		exception: 	a WAWalkbackErrorHandler
		handlerAction: 	[ :exception | 
[ self handleException: exception ]
	on: Error
	...etc...
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WAActionPhaseContinuation)...etc...
		startpc: 	30
		numArgs: 	0


WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
	Receiver: a WAWalkbackErrorHandler
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
	Receiver's instance variables: 
		requestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5PmB...etc...


[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ currentHandler handleExceptionsDuring: aBlock ]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[ :n |  ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARenderLoopContinuation)>...etc...
		startpc: 	61
		numArgs: 	0


WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ self basicPerformAction ]
		currentHandler: 	a WAWalkbackErrorHandler
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>ensure:
	Receiver: [ super performAction ]
	Arguments and temporary variables: 
		aBlock: 	[ self request isXmlHttpRequest
	ifTrue: [ self captureState ] ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation>>performAction
		startpc: 	41
		numArgs: 	0


WACallbackProcessingActionContinuation>>performAction
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5Pm...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5Pm...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ self filter handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
		handlerAction: 	[ :notification | notification resume: anObject ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WARequestHandler)>>handle:...etc...
		startpc: 	32
		numArgs: 	0


WACurrentRequestContext class(WADynamicVariable class)>>use:during:
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 
		anObject: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5PmB00KYjI...etc...
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5PmB00KYjItu'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=hPOA5PmB00...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


BlockClosure>>ensure:
	Receiver: [ WACurrentRequestContext use: self during: aBlock ]
	Arguments and temporary variables: 
		aBlock: 	[ handlers removeFirst ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WARequestContext>>push:during:
		startpc: 	42
		numArgs: 	0


WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5PmB00KYjItu'
	Arguments and temporary variables: 
		aRequestHandler: 	a WACallbackProcessingActionContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WACallbackProcessingActionContinuation a WASes...etc...
		request: 	a WARequest method: POST uri: /admin?_s=orB-26pkkUoms4Sb&_k=hPOA5PmB00...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	nil


WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5Pm...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5Pm...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


BlockClosure>>on:do:
	Receiver: [ super handle: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[ :err | self requestContext redirectTo: self application url ]
	Receiver's instance variables: 
		outerContext: 	WACallbackProcessingActionContinuation(WASessionContinuation)>>ha...etc...
		startpc: 	39
		numArgs: 	0


WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aBlock: 	[ super handle: aRequestContext ]
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
	Receiver: a WACallbackProcessingActionContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5Pm...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WACallbackProcessingActionContinuation
		parent: 	a WASession
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot
		renderContext: 	a WARenderContext
		jumpTo: 	nil


WASession>>handleFiltered:
	Receiver: a WASession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5Pm...etc...
		continationKey: 	'hPOA5PmB00KYjItu'
		continuation: 	a WACallbackProcessingActionContinuation
		fields: 	a WAMergedRequestFields
		documentHandlerKey: 	nil
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WAHashCache
		properties: 	a GRSmallDictionary(#presenter->a CWAdminComponent)
		documentHandlers: 	nil
		key: 	'orB-26pkkUoms4Sb'


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5Pm...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1877312
		previousTiming: 	4


[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5Pm...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1877312
		previousTiming: 	4


BlockClosure>>ensure:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		aBlock: 	[ previousTiming := self currentTiming ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5Pm...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WASession
		startTime: 	1877312
		previousTiming: 	4


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5Pm...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_s=orB-26pkkUoms4Sb&_k=hPOA5Pm...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ super handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :notification | self deprecated: notification ]
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	50
		numArgs: 	0



--- The full stack ---
CWAdminComponent>>save
[ self save ] in CWAdminComponent>>renderButtonsOn:
BlockClosure>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[ :callback | callback evaluateWithFieldValues: (fields allAt: callback key) ] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
WACallbackProcessingActionContinuation>>basicPerformAction
[ self basicPerformAction ] in WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
[ currentHandler handleExceptionsDuring: aBlock ] in WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>performAction
[ super performAction ] in WACallbackProcessingActionContinuation>>performAction
BlockClosure>>ensure:
WACallbackProcessingActionContinuation>>performAction
WACallbackProcessingActionContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WACallbackProcessingActionContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WACallbackProcessingActionContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WACallbackProcessingActionContinuation(WASessionContinuation)>>handle:
WASession>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handleKeyed:with:context:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

