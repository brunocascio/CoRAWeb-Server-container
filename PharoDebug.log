THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:54.834843 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 208 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122749
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 208 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 208 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	3


VOMongoRepositoryResolver>>execute:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aBlockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: li...etc...
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepository>>selectMany:where:
	Receiver: a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		selected: 	nil
	Receiver's instance variables: 
		port: 	27017
		databaseName: 	'CoRAWeb'
		host: 	'127.0.0.1'
		username: 	'admin'
		password: 	'admin123'
		cache: 	Cache(0 objects)
		descriptionBuilder: 	nil
		resolver: 	a VOMongoRepositoryResolver
		forceEager: 	false
		versionGenerator: 	a VOSeedVersionGenerator


VOMongoRepository>>selectAll:
	Receiver: a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
	Arguments and temporary variables: 
		aClass: 	Item
	Receiver's instance variables: 
		port: 	27017
		databaseName: 	'CoRAWeb'
		host: 	'127.0.0.1'
		username: 	'admin'
		password: 	'admin123'
		cache: 	Cache(0 objects)
		descriptionBuilder: 	nil
		resolver: 	a VOMongoRepositoryResolver
		forceEager: 	false
		versionGenerator: 	a VOSeedVersionGenerator


Item class(Class)>>selectAll
	Receiver: Item
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	CAModel
		methodDict: 	a MethodDictionary(#=->Item>>#= #asPropertyDictionary->Item>>#asPro...etc...
		format: 	65541
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Item
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CoRAWeb-model'
		traitComposition: 	{}
		localSelectors: 	nil


CWItemsListComponent>>items
	Receiver: a CWItemsListComponent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		urlToPost: 	nil


[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
	Receiver: a CWItemsListComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		urlToPost: 	nil


BlockClosure>>renderOn:
	Receiver: [ self items do: [ :it | self renderItem: it on: html ] ]
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	table...etc...
		startpc: 	128
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
	Receiver: a WAGenericTag
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a TBSTableTag
		closed: 	false
		attributes: 	nil
		tag: 	'tbody'


BlockClosure>>renderOn:
	Receiver: [ self before.
canvas render: anObject.
self after ]
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	WAGenericTag(WATagBrush)>>with:
		startpc: 	54
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>nest:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAGenericTag(WABrush)>>with:
	Receiver: a WAGenericTag
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a TBSTableTag
		closed: 	false
		attributes: 	nil
		tag: 	'tbody'


WAGenericTag(WATagBrush)>>with:
	Receiver: a WAGenericTag
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a TBSTableTag
		closed: 	false
		attributes: 	nil
		tag: 	'tbody'


WAHtmlCanvas>>tableBody:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
	Receiver: a CWItemsListComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		urlToPost: 	nil


BlockClosure>>renderOn:
	Receiver: [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ ...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: h...etc...
		startpc: 	110
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
	Receiver: a TBSTableTag
	Arguments and temporary variables: 
		anObject: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody...etc...
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a WAGenericTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'table')



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:54.950134 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 206 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122879
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 206 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 206 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 208 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122749
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 208 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 208 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:55.010724 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122943
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 206 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122879
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 206 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 206 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:55.061432 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 208 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122993
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 208 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 208 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122943
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in WeakIdentityKeyDictionary(Dictionary)>>at:ifAbsent:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in WeakIdentityKeyDictionary(Dictionary)>>at:ifAbsent:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in WeakIdentityKeyDictionary(Dictionary)>>at:ifAbsent:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

11 May 2017 1:45:55.109685 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 208 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122993
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 208 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 32 208 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	122943
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 144 34 1 2]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in WeakIdentityKeyDictionary(Dictionary)>>at:ifAbsent:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'



--- The full stack ---
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:56.985978 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 160 62 198 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	124913
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 160 62 198 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 160 62 198 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	3


VOMongoRepositoryResolver>>execute:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aBlockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: li...etc...
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepository>>selectMany:where:
	Receiver: a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		selected: 	nil
	Receiver's instance variables: 
		port: 	27017
		databaseName: 	'CoRAWeb'
		host: 	'127.0.0.1'
		username: 	'admin'
		password: 	'admin123'
		cache: 	Cache(0 objects)
		descriptionBuilder: 	nil
		resolver: 	a VOMongoRepositoryResolver
		forceEager: 	false
		versionGenerator: 	a VOSeedVersionGenerator


VOMongoRepository>>selectAll:
	Receiver: a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
	Arguments and temporary variables: 
		aClass: 	Item
	Receiver's instance variables: 
		port: 	27017
		databaseName: 	'CoRAWeb'
		host: 	'127.0.0.1'
		username: 	'admin'
		password: 	'admin123'
		cache: 	Cache(0 objects)
		descriptionBuilder: 	nil
		resolver: 	a VOMongoRepositoryResolver
		forceEager: 	false
		versionGenerator: 	a VOSeedVersionGenerator


Item class(Class)>>selectAll
	Receiver: Item
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	CAModel
		methodDict: 	a MethodDictionary(#=->Item>>#= #asPropertyDictionary->Item>>#asPro...etc...
		format: 	65541
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Item
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CoRAWeb-model'
		traitComposition: 	{}
		localSelectors: 	nil


CWItemsListComponent>>items
	Receiver: a CWItemsListComponent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		urlToPost: 	nil


[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
	Receiver: a CWItemsListComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		urlToPost: 	nil


BlockClosure>>renderOn:
	Receiver: [ self items do: [ :it | self renderItem: it on: html ] ]
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	table...etc...
		startpc: 	128
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
	Receiver: a WAGenericTag
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a TBSTableTag
		closed: 	false
		attributes: 	nil
		tag: 	'tbody'


BlockClosure>>renderOn:
	Receiver: [ self before.
canvas render: anObject.
self after ]
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	WAGenericTag(WATagBrush)>>with:
		startpc: 	54
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>nest:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAGenericTag(WABrush)>>with:
	Receiver: a WAGenericTag
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a TBSTableTag
		closed: 	false
		attributes: 	nil
		tag: 	'tbody'


WAGenericTag(WATagBrush)>>with:
	Receiver: a WAGenericTag
	Arguments and temporary variables: 
		anObject: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a TBSTableTag
		closed: 	false
		attributes: 	nil
		tag: 	'tbody'


WAHtmlCanvas>>tableBody:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ self items do: [ :it | self renderItem: it on: html ] ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
	Receiver: a CWItemsListComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		urlToPost: 	nil


BlockClosure>>renderOn:
	Receiver: [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ ...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: h...etc...
		startpc: 	110
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WAGenericTag


[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
	Receiver: a TBSTableTag
	Arguments and temporary variables: 
		anObject: 	[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody...etc...
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	a WAGenericTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'table')



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:57.047278 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	124971
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	2


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 160 62 198 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	124913
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 160 62 198 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 160 62 198 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in Socket>>waitForConnectionFor:ifTimedOut:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in Socket>>waitForConnectionFor:ifTimedOut:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in Socket>>waitForConnectionFor:ifTimedOut:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:57.100782 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	125029
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	1


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	124971
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 194 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Cannot connect to 127.0.0.1:27017
11 May 2017 1:45:57.151883 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	125085
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	125029
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil



--- The full stack ---
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

11 May 2017 1:45:57.202009 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	125085
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	125029
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 196 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in DelayExperimentalSpinScheduler>>schedule:
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'



--- The full stack ---
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
VOMongoConnectionError
11 May 2017 1:45:57.252218 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

VOMongoExecuteStrategy>>visitError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	VOMongoConnectionError
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoConnectionError(Error)>>acceptVOMongoExecuteError:
	Receiver: VOMongoConnectionError
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		signalContext: 	VOMongoConnectionError(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	VOMongoConnectionError
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	VOMongoConnectionError
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	VOMongoConnectionError
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	VOMongoConnectionError
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


VOMongoConnectionError(Exception)>>signalIn:
	Receiver: VOMongoConnectionError
	Arguments and temporary variables: 
		context: 	ConnectionTimedOut(Exception)>>signal
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		signalContext: 	VOMongoConnectionError(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>resignalAs:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		replacementException: 	VOMongoConnectionError
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


VOMongoExecuteStrategy>>resignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		aVOMongoExecuteStrategy: 	a VOMongoExecuteStrategy
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


BlockClosure>>cull:
	Receiver: [ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ]
	Arguments and temporary variables: 
		anArg: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		outerContext: 	VOMongoExecuteStrategy>>execute
		startpc: 	35
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
		value: 	nil
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		sender: 	VOMongoExecuteStrategy>>execute
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	...etc...


ConnectionTimedOut(Exception)>>signal
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut(Exception)>>signal:
	Receiver: ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Arguments and temporary variables: 
		signalerText: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		messageText: 	'Cannot connect to 127.0.0.1:27017'
		tag: 	nil
		signaler: 	a Socket[unconnected]
		signalContext: 	ConnectionTimedOut(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil


ConnectionTimedOut class(Exception class)>>signal:
	Receiver: ConnectionTimedOut
	Arguments and temporary variables: 
		message: 	'Cannot connect to 127.0.0.1:27017'
	Receiver's instance variables: 
		superclass: 	NetworkError
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConnectionTimedOut
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>waitForConnectionFor:ifTimedOut:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		timeout: 	45
		timeoutBlock: 	[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNam...etc...
		startTime: 	125085
		msecsDelta: 	45000
		msecsEllapsed: 	0
		status: 	0
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


Socket>>connectTo:port:waitForConnectionFor:
	Receiver: a Socket[unconnected]
	Arguments and temporary variables: 
		hostAddress: 	#[127 0 0 1]
		port: 	27017
		timeout: 	45
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		socketHandle: 	#[182 222 30 89 0 0 0 0 176 197 212 17]
		readSemaphore: 	a Semaphore()
		writeSemaphore: 	a Semaphore()


SocketStream class>>openConnectionToHost:port:timeout:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
		timeout: 	45
		socket: 	a Socket[unconnected]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHost:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostIP: 	#[127 0 0 1]
		portNumber: 	27017
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


SocketStream class>>openConnectionToHostNamed:port:
	Receiver: SocketStream
	Arguments and temporary variables: 
		hostName: 	'127.0.0.1'
		portNumber: 	27017
		hostIP: 	#[127 0 0 1]
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#'<<'->SocketStream>>#'<<' #adjustInBuffer:->Soc...etc...
		format: 	65548
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SocketStream
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Network-Kernel'
		traitComposition: 	{}
		localSelectors: 	nil


GratuitousIncompatibilities class>>socketStreamHost:port:
	Receiver: GratuitousIncompatibilities
	Arguments and temporary variables: 
		aString: 	'127.0.0.1'
		anInteger: 	27017
		result: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GratuitousIncompatibilities
		classPool: 	a Dictionary(#UTF8Codec->nil #UTF8Converter->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Mongo-Squeak'
		traitComposition: 	{}
		localSelectors: 	nil


Mongo>>open
	Receiver: Mongo (127.0.0.1:27017)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	'127.0.0.1'
		port: 	27017
		stream: 	nil
		requestID: 	0
		authCache: 	nil


VOMongoSessionPool(VOSessionPool)>>ensureConnected:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aSession: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool(VOSessionPool)>>obtainSession
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		session: 	Mongo (127.0.0.1:27017)
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoSessionPool>>withDatabase:
	Receiver: a VOMongoSessionPool
	Arguments and temporary variables: 
		aBlock: 	[ :db | 
| collection |
(self collectionAt: aClass inDatabase: db)
	sel...etc...
		session: 	nil
		db: 	nil
	Receiver's instance variables: 
		sessions: 	SharedQueue with 0 items
		size: 	10
		mutex: 	a Semaphore()
		process: 	a Process in [ self value.
Processor terminateActive ] in BlockClosure...etc...
		host: 	'127.0.0.1'
		port: 	27017
		database: 	'CoRAWeb'
		username: 	'admin'
		password: 	'admin123'


VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
	Receiver: a VOMongoRepositoryResolver
	Arguments and temporary variables: 
		aClass: 	Item
		aDictionary: 	a Dictionary()
		limit: 	nil
		offset: 	0
	Receiver's instance variables: 
		debug: 	false
		repository: 	a VOMongoRepository(127.0.0.1:27017/CoRAWeb)
		pool: 	a VOMongoSessionPool
		collections: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | 
self logError: error.
error acceptVOMongoExecuteErro...etc...
	Receiver's instance variables: 
		outerContext: 	VOMongoRepositoryResolver>>selectMany:where:limit:offset:
		startpc: 	30
		numArgs: 	0


VOMongoExecuteStrategy>>execute
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>retryOrResignal:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>handleConnectionError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		error: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0


VOMongoExecuteStrategy>>visitNetworkError:
	Receiver: a VOMongoExecuteStrategy
	Arguments and temporary variables: 
		aNetworkError: 	ConnectionTimedOut: Cannot connect to 127.0.0.1:27017
	Receiver's instance variables: 
		resolver: 	a VOMongoRepositoryResolver
		blockClosure: 	[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: lim...etc...
		retriesLeft: 	0



--- The full stack ---
VOMongoExecuteStrategy>>visitError:
VOMongoConnectionError(Error)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
VOMongoConnectionError(Exception)>>signalIn:
ConnectionTimedOut(Exception)>>resignalAs:
VOMongoExecuteStrategy>>resignal:
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoExecuteStrategy>>retryOrResignal:
VOMongoExecuteStrategy>>handleConnectionError:
VOMongoExecuteStrategy>>visitNetworkError:
ConnectionTimedOut(NetworkError)>>acceptVOMongoExecuteError:
[ :error | 
self logError: error.
error acceptVOMongoExecuteError: self ] in VOMongoExecuteStrategy>>execute
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
ConnectionTimedOut(Exception)>>signal
ConnectionTimedOut(Exception)>>signal:
ConnectionTimedOut class(Exception class)>>signal:
[ ConnectionTimedOut
	signal:
		'Cannot connect to '
			, (NetNameResolver stringFromAddress: hostAddress) , ':'
			, port asString ] in Socket>>connectTo:port:waitForConnectionFor:
Socket>>waitForConnectionFor:ifTimedOut:
Socket>>connectTo:port:waitForConnectionFor:
SocketStream class>>openConnectionToHost:port:timeout:
SocketStream class>>openConnectionToHost:port:
SocketStream class>>openConnectionToHostNamed:port:
GratuitousIncompatibilities class>>socketStreamHost:port:
Mongo>>open
VOMongoSessionPool(VOSessionPool)>>ensureConnected:
VOMongoSessionPool(VOSessionPool)>>obtainSession
VOMongoSessionPool>>withDatabase:
VOMongoRepositoryResolver>>basicRawSelectMany:where:limit:offset:
VOMongoRepositoryResolver>>basicSelectMany:where:limit:offset:
[ ^ self
	basicSelectMany: aClass
	where: aDictionary
	limit: limit
	offset: offset ] in VOMongoRepositoryResolver>>selectMany:where:limit:offset:
BlockClosure>>on:do:
VOMongoExecuteStrategy>>execute
VOMongoRepositoryResolver>>execute:
VOMongoRepositoryResolver>>selectMany:where:limit:offset:
VOMongoRepository>>selectMany:where:
VOMongoRepository>>selectAll:
Item class(Class)>>selectAll
CWItemsListComponent>>items
[ self items do: [ :it | self renderItem: it on: html ] ] in [ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tableBody:
[ html tableHead: [ self renderTableHeaderOn: html ].
html
	tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] in [ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSTableTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSTableTag(WABrush)>>with:
TBSTableTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsTable:
[ html
	tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
		html
			tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] in [ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in WAGenericTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
WAGenericTag(WABrush)>>with:
WAGenericTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsPanelBody:
[ html
	tbsPanelHeading: [ html tbsPanelTitle
			level: 3;
			with: 'Items already in the repository' ].
html
	tbsPanelBody: [ html
			tbsTable: [ html tableHead: [ self renderTableHeaderOn: html ].
				html
					tableBody: [ self items do: [ :it | self renderItem: it on: html ] ] ] ] ] in CWItemsListComponent>>renderItemsTableOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSPanelTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSPanelTag(WABrush)>>with:
TBSPanelTag(WATagBrush)>>with:
CWItemsListComponent>>renderItemsTableOn:
CWItemsListComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWItemsListComponent(WAComponent)>>accept:
CWItemsListComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWItemsListComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWItemsListComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "not" is nil
11 May 2017 2:49:47.273063 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

UndefinedObject(Object)>>doesNotUnderstand: #not
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	not
		exception: 	MessageNotUnderstood: receiver of "not" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

CWAdminComponent>>renderContentOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
		group: 	a WARadioGroup
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WAToolDecoration(WADecoration)>>renderNextOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderChildOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderContentOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>acceptDecorated:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAPainter)>>renderWithContext:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderPhaseContinuation>>processRendering:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aResponse: 	a WABufferedResponse status: 200 message: 'OK'
		document: 	a WAHtmlDocument
		actionContinuation: 	a WACallbackProcessingActionContinuation
		renderContext: 	a WARenderContext
		actionUrl: 	/admin?_s=_ANYVEhGrOnv61LB&_k=SkVvRhejlo6Kdg7f
		actionBaseUrl: 	/admin?_s=_ANYVEhGrOnv61LB&_k=SkVvRhejlo6Kdg7f
		htmlRoot: 	a WAHtmlRoot
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_debugAction=_debug'
		response: 	a WABufferedResponse status: 200 message: 'OK'
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


WARequestContext>>respond:
	Receiver: a WARequestContext url: '/admin?_debugAction=_debug'
	Arguments and temporary variables: 
		aBlock: 	[ :response | self processRendering: response ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WARenderPhaseContinuation a WAInitialRenderLoo...etc...
		request: 	a WARequest method: GET uri: /admin?_debugAction=_debug version: HTTP/...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	a GRSmallDictionary()


WARenderPhaseContinuation(WASessionContinuation)>>respond:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[ :response | self processRendering: response ]
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


WARenderPhaseContinuation>>handleFiltered:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_debugAction=_debug'
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
	Receiver: a WARenderPhaseContinuation
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/admin?_debugAction=_debug'
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WARenderPhaseContinuation
		parent: 	nil
		configuration: 	a WAUserConfiguration
		states: 	a WASnapshot


BlockClosure>>on:do:
	Receiver: [ self filter handleFiltered: aRequestContext ]
	Arguments and temporary variables: 
		exception: 	WACurrentRequestContext
		handlerAction: 	[ :notification | notification resume: anObject ]
	Receiver's instance variables: 
		outerContext: 	WARenderPhaseContinuation(WARequestHandler)>>handle:
		startpc: 	32
		numArgs: 	0


WACurrentRequestContext class(WADynamicVariable class)>>use:during:
	Receiver: WACurrentRequestContext
	Arguments and temporary variables: 
		anObject: 	a WARequestContext url: '/admin?_debugAction=_debug'
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		superclass: 	WADynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65542
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#WACurrentRequestContext
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Seaside-Core-RequestHandling'
		traitComposition: 	{}
		localSelectors: 	nil


[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_debugAction=_debug'
	Arguments and temporary variables: 
		aRequestHandler: 	a WARenderPhaseContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WARenderPhaseContinuation a WAInitialRenderLoo...etc...
		request: 	a WARequest method: GET uri: /admin?_debugAction=_debug version: HTTP/...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	a GRSmallDictionary()


BlockClosure>>ensure:
	Receiver: [ WACurrentRequestContext use: self during: aBlock ]
	Arguments and temporary variables: 
		aBlock: 	[ handlers removeFirst ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WARequestContext>>push:during:
		startpc: 	42
		numArgs: 	0


WARequestContext>>push:during:
	Receiver: a WARequestContext url: '/admin?_debugAction=_debug'
	Arguments and temporary variables: 
		aRequestHandler: 	a WARenderPhaseContinuation
		aBlock: 	[ self filter handleFiltered: aRequestContext ]
	Receiver's instance variables: 
		handlers: 	an OrderedCollection(a WARenderPhaseContinuation a WAInitialRenderLoo...etc...
		request: 	a WARequest method: GET uri: /admin?_debugAction=_debug version: HTTP/...etc...
		response: 	a WABufferedResponse status: 200 message: 'OK'
		codec: 	a GRPharoUtf8Codec name: 'utf-8'
		consumer: 	a WAPathConsumer
		properties: 	a GRSmallDictionary()



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #not
CWAdminComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWAdminComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
CWAdminComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: WAHtmlCanvas>>group
11 May 2017 2:59:39.751071 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

WAHtmlCanvas(Object)>>doesNotUnderstand: #group
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aMessage: 	group
		exception: 	MessageNotUnderstood: WAHtmlCanvas>>group
		resumeValue: 	nil
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


[ html group radioButton
	selected: PersistenceManager isLocal;
	callback: [ PersistenceManager beLocalWithEmptyRepository ].
html text: 'Local (starts with an empty repository)' ] in CWAdminComponent>>renderContentOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
		group: 	a WARadioGroup
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


BlockClosure>>renderOn:
	Receiver: [ html group radioButton
	selected: PersistenceManager isLocal;
	callback: [ PersistenceMa...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	CWAdminComponent>>renderContentOn:
		startpc: 	82
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


[ self before.
canvas render: anObject.
self after ] in TBSInputGroupTag(WATagBrush)>>with:
	Receiver: a TBSInputGroupTag
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'input-group')


BlockClosure>>renderOn:
	Receiver: [ self before.
canvas render: anObject.
self after ]
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	TBSInputGroupTag(WATagBrush)>>with:
		startpc: 	54
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


WAHtmlCanvas(WACanvas)>>nest:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


TBSInputGroupTag(WABrush)>>with:
	Receiver: a TBSInputGroupTag
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'input-group')


TBSInputGroupTag(WATagBrush)>>with:
	Receiver: a TBSInputGroupTag
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'input-group')


WAHtmlCanvas>>tbsInputGroup:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	callba...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


CWAdminComponent>>renderContentOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
		group: 	a WARadioGroup
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WAToolDecoration(WADecoration)>>renderNextOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderChildOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderContentOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>acceptDecorated:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor



--- The full stack ---
WAHtmlCanvas(Object)>>doesNotUnderstand: #group
[ html group radioButton
	selected: PersistenceManager isLocal;
	callback: [ PersistenceManager beLocalWithEmptyRepository ].
html text: 'Local (starts with an empty repository)' ] in CWAdminComponent>>renderContentOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSInputGroupTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSInputGroupTag(WABrush)>>with:
TBSInputGroupTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsInputGroup:
CWAdminComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWAdminComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CWAdminComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: WAHtmlCanvas>>group
11 May 2017 2:59:58.837396 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

WAHtmlCanvas(Object)>>doesNotUnderstand: #group
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aMessage: 	group
		exception: 	MessageNotUnderstood: WAHtmlCanvas>>group
		resumeValue: 	nil
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


[ html group radioButton
	selected: PersistenceManager isLocal;
	callback: [ PersistenceManager beLocalWithEmptyRepository ].
html text: 'Local (starts with an empty repository)' ] in CWAdminComponent>>renderContentOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
		group: 	a WARadioGroup
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


BlockClosure>>renderOn:
	Receiver: [ html group radioButton
	selected: PersistenceManager isLocal;
	callback: [ PersistenceMa...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	CWAdminComponent>>renderContentOn:
		startpc: 	82
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


[ self before.
canvas render: anObject.
self after ] in TBSInputGroupTag(WATagBrush)>>with:
	Receiver: a TBSInputGroupTag
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'input-group')


BlockClosure>>renderOn:
	Receiver: [ self before.
canvas render: anObject.
self after ]
	Arguments and temporary variables: 
		aRenderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		outerContext: 	TBSInputGroupTag(WATagBrush)>>with:
		startpc: 	54
		numArgs: 	0


WAHtmlCanvas(WARenderer)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


WAHtmlCanvas(WACanvas)>>render:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		anObject: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


WAHtmlCanvas(WACanvas)>>nest:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


TBSInputGroupTag(WABrush)>>with:
	Receiver: a TBSInputGroupTag
	Arguments and temporary variables: 
		aBlock: 	[ self before.
canvas render: anObject.
self after ]
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'input-group')


TBSInputGroupTag(WATagBrush)>>with:
	Receiver: a TBSInputGroupTag
	Arguments and temporary variables: 
		anObject: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	call...etc...
	Receiver's instance variables: 
		canvas: 	a WAHtmlCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'input-group')


WAHtmlCanvas>>tbsInputGroup:
	Receiver: a WAHtmlCanvas
	Arguments and temporary variables: 
		aBlock: 	[ html group radioButton
	selected: PersistenceManager isLocal;
	callba...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a TBSInputGroupTag


CWAdminComponent>>renderContentOn:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
		group: 	a WARadioGroup
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a CWAdminComponent
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>accept:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WAToolDecoration(WADecoration)>>renderNextOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderChildOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WAToolDecoration>>renderContentOn:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		html: 	a WAHtmlCanvas
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
		renderer: 	a WAHtmlCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a WAToolDecoration
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitDecoration:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aDecoration: 	a WAToolDecoration
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WAToolDecoration(WADecoration)>>accept:
	Receiver: a WAToolDecoration
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a CWAdminComponent
		plugins: 	an OrderedCollection(a WANewSessionToolPlugin a WAConfigureToolPlugin ...etc...
		showHalos: 	a WAValueHolder contents: false
		halos: 	an IdentityDictionary()


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor


CWAdminComponent(WAComponent)>>acceptDecorated:
	Receiver: a CWAdminComponent
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a CWAdminComponent
	Receiver's instance variables: 
		client: 	a WARenderVisitor



--- The full stack ---
WAHtmlCanvas(Object)>>doesNotUnderstand: #group
[ html group radioButton
	selected: PersistenceManager isLocal;
	callback: [ PersistenceManager beLocalWithEmptyRepository ].
html text: 'Local (starts with an empty repository)' ] in CWAdminComponent>>renderContentOn:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
[ self before.
canvas render: anObject.
self after ] in TBSInputGroupTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WAHtmlCanvas(WARenderer)>>render:
WAHtmlCanvas(WACanvas)>>render:
WAHtmlCanvas(WACanvas)>>nest:
TBSInputGroupTag(WABrush)>>with:
TBSInputGroupTag(WATagBrush)>>with:
WAHtmlCanvas>>tbsInputGroup:
CWAdminComponent>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
CWAdminComponent(WAComponent)>>accept:
CWAdminComponent(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
CWAdminComponent(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CWAdminComponent(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[ :response | self processRendering: response ] in WARenderPhaseContinuation>>handleFiltered:
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WARenderPhaseContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WARenderPhaseContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WARenderPhaseContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>handle:
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>continue
WAInitialRenderLoopContinuation(WAActionPhaseContinuation)>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAInitialRenderLoopContinuation(WARequestHandler)>>handle:
[ super handle: aRequestContext ] in WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
BlockClosure>>on:do:
WAInitialRenderLoopContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAInitialRenderLoopContinuation(WASessionContinuation)>>handle:
WASession>>start
[ ^ self start ] in WASession>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
WASession>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[ self owner: process.
aBlock
	ensure: [ self owner: nil ] ] in WAMutex>>critical:
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WASession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WASession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:key:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[ super handleFiltered: aRequestContext ] in [ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WACurrentExceptionHandler class(WADynamicVariable class)>>use:during:
[ WACurrentExceptionHandler
	use: handler
	during: [ super handleFiltered: aRequestContext ] ] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAExceptionFilter>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[ self filter handleFiltered: aRequestContext ] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[ WACurrentRequestContext use: self during: aBlock ] in WARequestContext>>push:during:
BlockClosure>>ensure:
WARequestContext>>push:during:
WADispatcher(WARequestHandler)>>handle:
[ self requestHandler handle: aRequestContext ] in ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
ZnZincServerAdaptor(WAServerAdaptor)>>handleRequest:
ZnZincServerAdaptor(WAServerAdaptor)>>handle:
[ self
	handle: context;
	responseFrom: context ] in ZnZincServerAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
ZnZincServerAdaptor(WAServerAdaptor)>>process:
ZnSeasideServerAdaptorDelegate>>handleRequest:
[ self delegate
	ifNil: [ ZnResponse notFound: request uri ]
	ifNotNil: [ :delegate | delegate handleRequest: request ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateRequest:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>authenticateAndDelegateRequest:
[ self authenticateAndDelegateRequest: request ] in [ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
[ [ self authenticateAndDelegateRequest: request ]
	on: ZnRespond
	do: [ :notification | notification response ] ] in ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
BlockClosure>>on:do:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequestProtected:
ZnManagingMultiThreadedServer(ZnSingleThreadedServer)>>handleRequest:timing:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeOneRequestResponseOn:
[ [ self executeOneRequestResponseOn: stream ] whileFalse ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnCurrentServer(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnCurrentServer(DynamicVariable)>>value:during:
ZnCurrentServer class(DynamicVariable class)>>value:during:
ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>executeRequestResponseLoopOn:
[ self executeRequestResponseLoopOn: stream ] in [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ensure:
[ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ] in [ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
BlockClosure>>ifCurtailed:
[ [ [ self executeRequestResponseLoopOn: stream ]
	ensure: [ self logConnectionClosed: stream.
		self closeSocketStream: stream ] ]
	ifCurtailed: [ socket destroy ] ] in ZnManagingMultiThreadedServer(ZnMultiThreadedServer)>>serveConnectionsOn:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ZnHttpUnsuccessful: 400 Bad Request
11 May 2017 3:44:00.796767 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

ZnClient>>handleResponse
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>executeWithRedirectsRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		redirectCount: 	3
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ self executeWithRedirectsRemaining: self maxNumberOfRedirects ] in ZnClient>>executeWithRetriesRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		retryCount: 	0
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


BlockClosure>>on:do:
	Receiver: [ self executeWithRedirectsRemaining: self maxNumberOfRedirects ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :exception | 
retryCount > 0
	ifTrue: [ self
			handleRetry: e...etc...
	Receiver's instance variables: 
		outerContext: 	ZnClient>>executeWithRetriesRemaining:
		startpc: 	49
		numArgs: 	0


ZnClient>>executeWithRetriesRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		retryCount: 	0
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ self executeWithRetriesRemaining: self numberOfRetries ] in [ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


BlockClosure>>on:do:
	Receiver: [ self executeWithRetriesRemaining: self numberOfRetries ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :exception | 
((exception isKindOf: ZnHttpUnsuccessful)
	and: ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on:...etc...
		startpc: 	46
		numArgs: 	0


[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ ^ block value ] in ZnClient>>withTimeoutDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
...etc...
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ p psValueAt: index put: anObject.
aBlock value ] in ZnConnectionTimeout(DynamicVariable)>>value:during:
	Receiver: a ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	1


BlockClosure>>ensure:
	Receiver: [ p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ZnConnectionTimeout(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


ZnConnectionTimeout(DynamicVariable)>>value:during:
	Receiver: a ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	1


ZnConnectionTimeout class(DynamicVariable class)>>value:during:
	Receiver: ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZnConnectionTimeout
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Variables'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a ZnConnectionTimeout


ZnClient>>withTimeoutDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
...etc...
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ result := self executeWithTimeout ] in ZnClient>>execute
	Receiver: a ZnClient
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ ^ block value ] in ZnClient>>withProgressDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ result := self executeWithTimeout ]
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ p psValueAt: index put: anObject.
aBlock value ] in ZnSignalProgress(DynamicVariable)>>value:during:
	Receiver: a ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	true
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


BlockClosure>>ensure:
	Receiver: [ p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ZnSignalProgress(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


ZnSignalProgress(DynamicVariable)>>value:during:
	Receiver: a ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	true
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


ZnSignalProgress class(DynamicVariable class)>>value:during:
	Receiver: ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	true
		aBlock: 	[ ^ block value ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZnSignalProgress
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Variables'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a ZnSignalProgress


ZnClient>>withProgressDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ result := self executeWithTimeout ]
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>execute
	Receiver: a ZnClient
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>head
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>head:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		url: 	'http://smalltalkhub.com/mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz'
	Receiver's instance variables: 
		request: 	a ZnRequest(HEAD /mc/casco/CoRAWeb/main/CoRAWeb-Casco.17.mcz)
		response: 	a ZnResponse(400 Bad Request)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


MCSmalltalkhubRepository>>includesFileNamed:
	Receiver: a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWeb/main/)
	Arguments and temporary variables: 
		aString: 	'CoRAWeb-Casco.17.mcz'
	Receiver's instance variables: 
		creationTemplate: 	'MCSmalltalkhubRepository
	owner: ''casco''
	project: ''CoRAW...etc...
		cache: 	a Dictionary('CoRAWeb-Casco.10.mcz'->a MCVersion(CoRAWeb-Casco.10) 'CoRA...etc...
		allFileNames: 	nil
		cacheFileNames: 	false
		location: 	nil
		user: 	'casco'
		password: 	'rodrigo'
		readerCache: 	a Dictionary('CoRAWeb-Casco.10.mcz'->a MCMczReader )
		owner: 	'casco'
		project: 	'CoRAWeb'


MCSmalltalkhubRepository>>includesVersionNamed:
	Receiver: a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWeb/main/)
	Arguments and temporary variables: 
		aString: 	'CoRAWeb-Casco.17'
	Receiver's instance variables: 
		creationTemplate: 	'MCSmalltalkhubRepository
	owner: ''casco''
	project: ''CoRAW...etc...
		cache: 	a Dictionary('CoRAWeb-Casco.10.mcz'->a MCVersion(CoRAWeb-Casco.10) 'CoRA...etc...
		allFileNames: 	nil
		cacheFileNames: 	false
		location: 	nil
		user: 	'casco'
		password: 	'rodrigo'
		readerCache: 	a Dictionary('CoRAWeb-Casco.10.mcz'->a MCMczReader )
		owner: 	'casco'
		project: 	'CoRAWeb'


[ :arg | 
[ versionName := self nextVersionName.
aRepository includesVersionNamed: versionName ] whileTrue ] in MCWorkingCopy>>uniqueVersionNameIn:
	Receiver: a MCWorkingCopy(CoRAWeb)
	Arguments and temporary variables: 
		aRepository: 	a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWe...etc...
		versionName: 	'CoRAWeb-Casco.17'
		arg: 	a Job
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		package: 	a MCPackage(CoRAWeb)
		modified: 	true
		ancestry: 	a MCWorkingAncestry
		counter: 	17
		repositoryGroup: 	a MCRepositoryGroup
		requiredPackages: 	an OrderedCollection()


BlockClosure>>cull:
	Receiver: [ :arg | 
[ versionName := self nextVersionName.
aRepository includesVersionNamed: version...etc...
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	MCWorkingCopy>>uniqueVersionNameIn:
		startpc: 	47
		numArgs: 	1


[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :arg | 
[ versionName := self nextVersionName.
aRepository includesVer...etc...
		currentValue: 	0
		min: 	0
		max: 	1
		title: 	'Creating unique version number'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


[ p psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	8


BlockClosure>>ensure:
	Receiver: [ p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	8


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :arg | 
[ versionName := self nextVersionName.
aRepository includesVer...etc...
		currentValue: 	0
		min: 	0
		max: 	1
		title: 	'Creating unique version number'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


BlockClosure>>ensure:
	Receiver: [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	41
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :arg | 
[ versionName := self nextVersionName.
aRepository includesVer...etc...
		currentValue: 	0
		min: 	0
		max: 	1
		title: 	'Creating unique version number'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	'Creating unique version number'
		minVal: 	0
		maxVal: 	1
		workBlock: 	[ :arg | 
[ versionName := self nextVersionName.
aRepository include...etc...
	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


ByteString(String)>>displayProgressFrom:to:during:
	Receiver: 'Creating unique version number'
	Arguments and temporary variables: 
		minVal: 	0
		maxVal: 	1
		workBlock: 	[ :arg | 
[ versionName := self nextVersionName.
aRepository include...etc...
	Receiver's instance variables: 
'Creating unique version number'


--- The full stack ---
ZnClient>>handleResponse
ZnClient>>executeWithRedirectsRemaining:
[ self executeWithRedirectsRemaining: self maxNumberOfRedirects ] in ZnClient>>executeWithRetriesRemaining:
BlockClosure>>on:do:
ZnClient>>executeWithRetriesRemaining:
[ self executeWithRetriesRemaining: self numberOfRetries ] in [ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
BlockClosure>>on:do:
[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
[ ^ block value ] in ZnClient>>withTimeoutDo:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnConnectionTimeout(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnConnectionTimeout(DynamicVariable)>>value:during:
ZnConnectionTimeout class(DynamicVariable class)>>value:during:
ZnClient>>withTimeoutDo:
ZnClient>>executeWithTimeout
[ result := self executeWithTimeout ] in ZnClient>>execute
[ ^ block value ] in ZnClient>>withProgressDo:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnSignalProgress(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnSignalProgress(DynamicVariable)>>value:during:
ZnSignalProgress class(DynamicVariable class)>>value:during:
ZnClient>>withProgressDo:
ZnClient>>execute
ZnClient>>head
ZnClient>>head:
MCSmalltalkhubRepository>>includesFileNamed:
MCSmalltalkhubRepository>>includesVersionNamed:
[ :arg | 
[ versionName := self nextVersionName.
aRepository includesVersionNamed: versionName ] whileTrue ] in MCWorkingCopy>>uniqueVersionNameIn:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ p psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MCWorkingCopy>>uniqueVersionNameIn:
MCWorkingCopy>>newVersionIn:
NautilusMonticello>>commit:in:
[ self default commit: mcpackage workingCopy in: repo ] in [ :repo :index | 
last := (aBuilder item: 'Repo' , index printString)
	label: repo description;
	parent: #('Commit in ' #, #package #name);
	order: index;
	action: [ self default commit: mcpackage workingCopy in: repo ] ] in NautilusMonticello class>>packagesCommitsMenu:
BlockClosure>>cull:
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ].
		self showShortcut ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ [ World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Could not save version.
11 May 2017 3:46:38.133749 pm

VM: Mac OS - intel - 1094 - CoInterpreter VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
StackToRegisterMappingCogit VMMaker.oscog-HolgerHansPeterFreyther.1880 uuid: 16138eb3-2390-40f5-a6c8-15f0494936f8 Oct 10 2016
git@github.com:pharo-project/pharo-vm.git Commit: 06744effac0f0aa3b4b32e17636448f9d51d6707 Date: 2016-09-30 08:40:43 +0200 By: GitHub <noreply@github.com> 

Image: Pharo5.0 [Latest update: #50770]

MCSmalltalkhubRepository(MCHttpRepository)>>handleUnsuccessfulResponse:
	Receiver: a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWebMonitorUI/main/)
	Arguments and temporary variables: 
		aZnResponse: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
	Receiver's instance variables: 
		creationTemplate: 	'MCHttpRepository
	location: ''http://smalltalkhub.com/mc/cas...etc...
		cache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCVersion(CoRAWebMonit...etc...
		allFileNames: 	nil
		cacheFileNames: 	false
		location: 	nil
		user: 	'casco'
		password: 	'rodrigo'
		readerCache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCMczReader )
		owner: 	'casco'
		project: 	'CoRAWebMonitorUI'


[ :exception | 
(exception isKindOf: ZnHttpUnsuccessful)
	ifTrue: [ ^ self handleUnsuccessfulResponse: exception response ].
self error: 'Could not save ' , aString , ': ' , exception printString ] in [ self httpClient
	entity: entity;
	ifFail: [ :exception | 
		(exception isKindOf: ZnHttpUnsuccessful)
			ifTrue: [ ^ self handleUnsuccessfulResponse: exception response ].
		self
			error: 'Could not save ' , aString , ': ' , exception printString ];
	url: (self urlForFileNamed: aString);
	put ] in MCSmalltalkhubRepository(MCHttpRepository)>>writeStreamForFileNamed:replace:do:
	Receiver: a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWebMonitorUI/main/)
	Arguments and temporary variables: 
		aString: 	'CoRAWebMonitoringUI-Casco.8.mcz'
		ignoreBoolean: 	false
		aBlock: 	[ :s | aVersion fileOutOn: s ]
		entity: 	a ZnStreamingEntity(application/octet-stream 4577B)
		exception: 	ZnHttpUnsuccessful: 400 Bad Request
	Receiver's instance variables: 
		creationTemplate: 	'MCHttpRepository
	location: ''http://smalltalkhub.com/mc/cas...etc...
		cache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCVersion(CoRAWebMonit...etc...
		allFileNames: 	nil
		cacheFileNames: 	false
		location: 	nil
		user: 	'casco'
		password: 	'rodrigo'
		readerCache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCMczReader )
		owner: 	'casco'
		project: 	'CoRAWebMonitorUI'


BlockClosure>>cull:
	Receiver: [ :exception | 
(exception isKindOf: ZnHttpUnsuccessful)
	ifTrue: [ ^ self handleUnsuccess...etc...
	Arguments and temporary variables: 
		anArg: 	ZnHttpUnsuccessful: 400 Bad Request
	Receiver's instance variables: 
		outerContext: 	[ self httpClient
	entity: entity;
	ifFail: [ :exception | 
		(ex...etc...
		startpc: 	115
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ZnHttpUnsuccessful: 400 Bad Request
		value: 	nil
	Receiver's instance variables: 
		sender: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error...etc...
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self executeWithRetriesRemaining: self numberOfRetries ]


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ZnHttpUnsuccessful: 400 Bad Request
	Receiver's instance variables: 
		sender: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error...etc...
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self executeWithRetriesRemaining: self numberOfRetries ]


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ZnHttpUnsuccessful: 400 Bad Request
	Receiver's instance variables: 
		sender: 	ZnClient>>executeWithRetriesRemaining:
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ self executeWithRedirectsRemaining: self maxNumberOfRedirects ]


ZnHttpUnsuccessful(Exception)>>signal
	Receiver: ZnHttpUnsuccessful: 400 Bad Request
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'400 Bad Request'
		tag: 	nil
		signaler: 	a ZnClient
		signalContext: 	ZnHttpUnsuccessful(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)


ZnClient>>handleResponse
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>executeWithRedirectsRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		redirectCount: 	3
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ self executeWithRedirectsRemaining: self maxNumberOfRedirects ] in ZnClient>>executeWithRetriesRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		retryCount: 	2
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


BlockClosure>>on:do:
	Receiver: [ self executeWithRedirectsRemaining: self maxNumberOfRedirects ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :exception | 
retryCount > 0
	ifTrue: [ self
			handleRetry: e...etc...
	Receiver's instance variables: 
		outerContext: 	ZnClient>>executeWithRetriesRemaining:
		startpc: 	49
		numArgs: 	0


ZnClient>>executeWithRetriesRemaining:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		retryCount: 	2
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ self executeWithRetriesRemaining: self numberOfRetries ] in [ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


BlockClosure>>on:do:
	Receiver: [ self executeWithRetriesRemaining: self numberOfRetries ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :exception | 
(exception isKindOf: ZnHttpUnsuccessful)
	ifTrue...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on:...etc...
		startpc: 	46
		numArgs: 	0


[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ ^ block value ] in ZnClient>>withTimeoutDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
...etc...
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ p psValueAt: index put: anObject.
aBlock value ] in ZnConnectionTimeout(DynamicVariable)>>value:during:
	Receiver: a ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	1


BlockClosure>>ensure:
	Receiver: [ p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ZnConnectionTimeout(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


ZnConnectionTimeout(DynamicVariable)>>value:during:
	Receiver: a ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	1


ZnConnectionTimeout class(DynamicVariable class)>>value:during:
	Receiver: ZnConnectionTimeout
	Arguments and temporary variables: 
		anObject: 	30
		aBlock: 	[ ^ block value ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZnConnectionTimeout
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Variables'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a ZnConnectionTimeout


ZnClient>>withTimeoutDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
...etc...
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>executeWithTimeout
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ result := self executeWithTimeout ] in ZnClient>>execute
	Receiver: a ZnClient
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ ^ block value ] in ZnClient>>withProgressDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ result := self executeWithTimeout ]
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ p psValueAt: index put: anObject.
aBlock value ] in ZnSignalProgress(DynamicVariable)>>value:during:
	Receiver: a ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	true
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


BlockClosure>>ensure:
	Receiver: [ p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ZnSignalProgress(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0


ZnSignalProgress(DynamicVariable)>>value:during:
	Receiver: a ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	true
		aBlock: 	[ ^ block value ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	2


ZnSignalProgress class(DynamicVariable class)>>value:during:
	Receiver: ZnSignalProgress
	Arguments and temporary variables: 
		anObject: 	true
		aBlock: 	[ ^ block value ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ZnSignalProgress
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Zinc-HTTP-Variables'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a ZnSignalProgress


ZnClient>>withProgressDo:
	Receiver: a ZnClient
	Arguments and temporary variables: 
		block: 	[ result := self executeWithTimeout ]
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>execute
	Receiver: a ZnClient
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


ZnClient>>put
	Receiver: a ZnClient
	Arguments and temporary variables: 

	Receiver's instance variables: 
		request: 	a ZnRequest(PUT /mc/casco/CoRAWebMonitorUI/main/CoRAWebMonitoringUI-Ca...etc...
		response: 	a ZnResponse(400 Bad Request text/html;charset=iso-8859-1 226B)
		connection: 	nil
		lastUsed: 	nil
		options: 	a Dictionary(#enforceAcceptContentType->true #enforceHttpSuccess->true...etc...
		session: 	nil
		logLevel: 	3


[ self httpClient
	entity: entity;
	ifFail: [ :exception | 
		(exception isKindOf: ZnHttpUnsuccessful)
			ifTrue: [ ^ self handleUnsuccessfulResponse: exception response ].
		self
			error: 'Could not save ' , aString , ': ' , exception printString ];
	url: (self urlForFileNamed: aString);
	put ] in MCSmalltalkhubRepository(MCHttpRepository)>>writeStreamForFileNamed:replace:do:
	Receiver: a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWebMonitorUI/main/)
	Arguments and temporary variables: 
		aString: 	'CoRAWebMonitoringUI-Casco.8.mcz'
		ignoreBoolean: 	false
		aBlock: 	[ :s | aVersion fileOutOn: s ]
		entity: 	a ZnStreamingEntity(application/octet-stream 4577B)
	Receiver's instance variables: 
		creationTemplate: 	'MCHttpRepository
	location: ''http://smalltalkhub.com/mc/cas...etc...
		cache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCVersion(CoRAWebMonit...etc...
		allFileNames: 	nil
		cacheFileNames: 	false
		location: 	nil
		user: 	'casco'
		password: 	'rodrigo'
		readerCache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCMczReader )
		owner: 	'casco'
		project: 	'CoRAWebMonitorUI'


[ workBlock value ] in [ :bar | 
[ workBlock value ]
	on: HTTPProgress
	do: [ :ex | 
		(ex total == nil or: [ ex amount == nil ])
			ifFalse: [ (nextUpdateTime < Time millisecondClockValue
					or: [ ex total = ex amount ])
					ifTrue: [ bar current: ex amount asFloat / ex total asFloat.
						nextUpdateTime := Time millisecondClockValue + 100 ] ].
		ex resume ] ] in MCSmalltalkhubRepository(MCHttpRepository)>>displayProgress:during:
	Receiver: a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWebMonitorUI/main/)
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		creationTemplate: 	'MCHttpRepository
	location: ''http://smalltalkhub.com/mc/cas...etc...
		cache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCVersion(CoRAWebMonit...etc...
		allFileNames: 	nil
		cacheFileNames: 	false
		location: 	nil
		user: 	'casco'
		password: 	'rodrigo'
		readerCache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCMczReader )
		owner: 	'casco'
		project: 	'CoRAWebMonitorUI'


BlockClosure>>on:do:
	Receiver: [ workBlock value ]
	Arguments and temporary variables: 
		exception: 	HTTPProgress
		handlerAction: 	[ :ex | 
(ex total == nil or: [ ex amount == nil ])
	ifFalse: [ ...etc...
	Receiver's instance variables: 
		outerContext: 	[ :bar | 
[ workBlock value ]
	on: HTTPProgress
	do: [ :ex | 
		(...etc...
		startpc: 	108
		numArgs: 	0


[ :bar | 
[ workBlock value ]
	on: HTTPProgress
	do: [ :ex | 
		(ex total == nil or: [ ex amount == nil ])
			ifFalse: [ (nextUpdateTime < Time millisecondClockValue
					or: [ ex total = ex amount ])
					ifTrue: [ bar current: ex amount asFloat / ex total asFloat.
						nextUpdateTime := Time millisecondClockValue + 100 ] ].
		ex resume ] ] in MCSmalltalkhubRepository(MCHttpRepository)>>displayProgress:during:
	Receiver: a MCSmalltalkhubRepository(http://smalltalkhub.com/mc/casco/CoRAWebMonitorUI/main/)
	Arguments and temporary variables: 
		label: 	'Uploading CoRAWebMonitoringUI-Casco.8.mcz'
		workBlock: 	[ self httpClient
	entity: entity;
	ifFail: [ :exception | 
		(excep...etc...
		nextUpdateTime: 	0
		bar: 	a Job
	Receiver's instance variables: 
		creationTemplate: 	'MCHttpRepository
	location: ''http://smalltalkhub.com/mc/cas...etc...
		cache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCVersion(CoRAWebMonit...etc...
		allFileNames: 	nil
		cacheFileNames: 	false
		location: 	nil
		user: 	'casco'
		password: 	'rodrigo'
		readerCache: 	a Dictionary('CoRAWebMonitoringUI-Cacso.3.mcz'->a MCMczReader )
		owner: 	'casco'
		project: 	'CoRAWebMonitorUI'


BlockClosure>>cull:
	Receiver: [ :bar | 
[ workBlock value ]
	on: HTTPProgress
	do: [ :ex | 
		(ex total == nil or: [ ex ...etc...
	Arguments and temporary variables: 
		anArg: 	a Job
	Receiver's instance variables: 
		outerContext: 	MCSmalltalkhubRepository(MCHttpRepository)>>displayProgress:durin...etc...
		startpc: 	103
		numArgs: 	1


[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | 
[ workBlock value ]
	on: HTTPProgress
	do: [ :ex | 
		(ex tota...etc...
		currentValue: 	0.0
		min: 	0.0
		max: 	1.0
		title: 	'Uploading CoRAWebMonitoringUI-Casco.8.mcz'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


[ p psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		p: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	8


BlockClosure>>ensure:
	Receiver: [ p psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ p psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		startpc: 	62
		numArgs: 	0



--- The full stack ---
MCSmalltalkhubRepository(MCHttpRepository)>>handleUnsuccessfulResponse:
[ :exception | 
(exception isKindOf: ZnHttpUnsuccessful)
	ifTrue: [ ^ self handleUnsuccessfulResponse: exception response ].
self error: 'Could not save ' , aString , ': ' , exception printString ] in [ self httpClient
	entity: entity;
	ifFail: [ :exception | 
		(exception isKindOf: ZnHttpUnsuccessful)
			ifTrue: [ ^ self handleUnsuccessfulResponse: exception response ].
		self
			error: 'Could not save ' , aString , ': ' , exception printString ];
	url: (self urlForFileNamed: aString);
	put ] in MCSmalltalkhubRepository(MCHttpRepository)>>writeStreamForFileNamed:replace:do:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
Context>>handleSignal:
ZnHttpUnsuccessful(Exception)>>signal
ZnClient>>handleResponse
ZnClient>>executeWithRedirectsRemaining:
[ self executeWithRedirectsRemaining: self maxNumberOfRedirects ] in ZnClient>>executeWithRetriesRemaining:
BlockClosure>>on:do:
ZnClient>>executeWithRetriesRemaining:
[ self executeWithRetriesRemaining: self numberOfRetries ] in [ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
BlockClosure>>on:do:
[ [ self executeWithRetriesRemaining: self numberOfRetries ]
	on: Error
	do: self ifFailBlock ] in ZnClient>>executeWithTimeout
[ ^ block value ] in ZnClient>>withTimeoutDo:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnConnectionTimeout(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnConnectionTimeout(DynamicVariable)>>value:during:
ZnConnectionTimeout class(DynamicVariable class)>>value:during:
ZnClient>>withTimeoutDo:
ZnClient>>executeWithTimeout
[ result := self executeWithTimeout ] in ZnClient>>execute
[ ^ block value ] in ZnClient>>withProgressDo:
[ p psValueAt: index put: anObject.
aBlock value ] in ZnSignalProgress(DynamicVariable)>>value:during:
BlockClosure>>ensure:
ZnSignalProgress(DynamicVariable)>>value:during:
ZnSignalProgress class(DynamicVariable class)>>value:during:
ZnClient>>withProgressDo:
ZnClient>>execute
ZnClient>>put
[ self httpClient
	entity: entity;
	ifFail: [ :exception | 
		(exception isKindOf: ZnHttpUnsuccessful)
			ifTrue: [ ^ self handleUnsuccessfulResponse: exception response ].
		self
			error: 'Could not save ' , aString , ': ' , exception printString ];
	url: (self urlForFileNamed: aString);
	put ] in MCSmalltalkhubRepository(MCHttpRepository)>>writeStreamForFileNamed:replace:do:
[ workBlock value ] in [ :bar | 
[ workBlock value ]
	on: HTTPProgress
	do: [ :ex | 
		(ex total == nil or: [ ex amount == nil ])
			ifFalse: [ (nextUpdateTime < Time millisecondClockValue
					or: [ ex total = ex amount ])
					ifTrue: [ bar current: ex amount asFloat / ex total asFloat.
						nextUpdateTime := Time millisecondClockValue + 100 ] ].
		ex resume ] ] in MCSmalltalkhubRepository(MCHttpRepository)>>displayProgress:during:
BlockClosure>>on:do:
[ :bar | 
[ workBlock value ]
	on: HTTPProgress
	do: [ :ex | 
		(ex total == nil or: [ ex amount == nil ])
			ifFalse: [ (nextUpdateTime < Time millisecondClockValue
					or: [ ex total = ex amount ])
					ifTrue: [ bar current: ex amount asFloat / ex total asFloat.
						nextUpdateTime := Time millisecondClockValue + 100 ] ].
		ex resume ] ] in MCSmalltalkhubRepository(MCHttpRepository)>>displayProgress:during:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ p psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MCSmalltalkhubRepository(MCHttpRepository)>>displayProgress:during:
MCSmalltalkhubRepository(MCHttpRepository)>>writeStreamForFileNamed:replace:do:
MCSmalltalkhubRepository(MCFileBasedRepository)>>writeStreamForFileNamed:do:
MCSmalltalkhubRepository(MCFileBasedRepository)>>basicStoreVersion:
MCSmalltalkhubRepository(MCRepository)>>storeVersion:
MCSmalltalkhubRepository(MCFileBasedRepository)>>storeVersion:
[ super storeVersion: aVersion ] in MCSmalltalkhubRepository(MCHttpRepository)>>storeVersion:
BlockClosure>>on:do:
MCSmalltalkhubRepository(MCHttpRepository)>>retryOnCredentialRequest:
MCSmalltalkhubRepository(MCHttpRepository)>>storeVersion:
[ aRepository storeVersion: newVersion.
aRepository storeDependencies: newVersion ] in [ [ aRepository storeVersion: newVersion.
aRepository storeDependencies: newVersion ]
	ensure: [ (MCVersionInspector new version: newVersion) show ] ] in NautilusMonticello>>commit:in:
BlockClosure>>ensure:
[ [ aRepository storeVersion: newVersion.
aRepository storeDependencies: newVersion ]
	ensure: [ (MCVersionInspector new version: newVersion) show ] ] in NautilusMonticello>>commit:in:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
NautilusMonticello>>commit:in:
[ self default commit: mcpackage workingCopy in: repo ] in [ :repo :index | 
last := (aBuilder item: 'Repo' , index printString)
	label: repo description;
	parent: #('Commit in ' #, #package #name);
	order: index;
	action: [ self default commit: mcpackage workingCopy in: repo ] ] in NautilusMonticello class>>packagesCommitsMenu:
BlockClosure>>cull:
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ].
		self showShortcut ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ [ World doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

